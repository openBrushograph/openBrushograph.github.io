<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FluidNC Raster Generator</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #f4f4f9; padding: 20px; color: #333; }
        .container { max-width: 900px; margin: 0 auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h1 { margin-top: 0; color: #2c3e50; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .section { background: #fafafa; padding: 15px; border-radius: 6px; border: 1px solid #eee; }
        .section h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.1em; color: #2980b9; border-bottom: 2px solid #ddd; padding-bottom: 5px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; font-size: 0.9em; }
        input[type="number"], input[type="text"] { width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        .checkbox-group { display: flex; align-items: center; margin-bottom: 10px; }
        .checkbox-group input { width: auto; margin-right: 10px; }
        button { background: #27ae60; color: white; border: none; padding: 12px 20px; font-size: 16px; border-radius: 4px; cursor: pointer; width: 100%; margin-top: 10px; transition: background 0.3s; }
        button:hover { background: #219150; }
        #log { width: 100%; height: 150px; background: #222; color: #0f0; font-family: monospace; padding: 10px; border-radius: 4px; overflow-y: scroll; box-sizing: border-box; margin-top: 20px; font-size: 12px; }
        canvas { display: none; }
        .preview-area { margin-top: 20px; text-align: center; }
        .preview-area img { max-width: 100%; border: 1px solid #ddd; }
        .file-input { background: #ecf0f1; padding: 20px; text-align: center; border: 2px dashed #bdc3c7; border-radius: 6px; cursor: pointer; }
    </style>
</head>
<body>

<div class="container">
    <h1>Raster_painter</h1>
    
    <div class="file-input">
        <label for="imageInput" style="cursor: pointer;">ðŸ“‚ Click to Select Image</label>
        <input type="file" id="imageInput" accept="image/*" style="display:none">
        <div id="fileName">No file selected</div>
    </div>

    <div class="grid">
        <div class="section">
            <h3>Dimensions & Offsets</h3>
            <label>Output Width (mm)</label>
            <input type="number" id="width" value="140.0" step="0.1">
            <label>Max Depth (Z mm, negative)</label>
            <input type="number" id="maxDepth" value="-1.0" step="0.1">
            <label>Line Spacing (mm)</label>
            <input type="number" id="lineSpacing" value="0.6" step="0.1">
            <label>Feed Rate (mm/min)</label>
            <input type="number" id="feedRate" value="1500">
            <label>X Offset (mm)</label>
            <input type="number" id="xOffset" value="0.0">
            <label>Y Offset (mm)</label>
            <input type="number" id="yOffset" value="25.0">
        </div>

        <div class="section">
            <h3>Dipping & Wiping</h3>
            <label>Dip Trigger Distance (mm)</label>
            <input type="number" id="dipThreshold" value="500.0">
            <div class="grid" style="grid-template-columns: 1fr 1fr 1fr; gap: 5px; margin-bottom: 0;">
                <div><label>Dip X</label><input type="number" id="dipX" value="63.0"></div>
                <div><label>Dip Y</label><input type="number" id="dipY" value="0.0"></div>
                <div><label>Dip Z</label><input type="number" id="dipZ" value="0.0"></div>
            </div>
            <label>Dip Duration (sec)</label>
            <input type="number" id="dipDuration" value="0.001" step="0.1">
            <label>Wipe Radius (mm)</label>
            <input type="number" id="wipeRadius" value="15.0">
            <div class="checkbox-group">
                <input type="checkbox" id="removeDrops" checked>
                <label for="removeDrops">Enable Wipe/Shake</label>
            </div>
        </div>

        <div class="section">
            <h3>Z Heights & Backlash</h3>
            <label>Safe Z (Travel)</label>
            <input type="number" id="zSafe" value="2.0">
            <label>Safe Z (Dip Travel)</label>
            <input type="number" id="zSafeDip" value="5.0">
            <label>Wipe Height (Z)</label>
            <input type="number" id="zWipe" value="2.0">
            <label>Global Z Offset</label>
            <input type="number" id="zGlobal" value="0.0">
            <hr>
            <label>Backlash X (mm)</label>
            <input type="number" id="bx" value="0.5" step="0.01">
            <label>Backlash Y (mm)</label>
            <input type="number" id="by" value="1.6" step="0.01">
        </div>
    </div>

    <button id="generateBtn" onclick="generateGCode()">ðŸš€ Generate G-Code</button>
    <button id="downloadBtn" onclick="downloadGCode()" style="background: #3498db; display:none; margin-top: 10px;">ðŸ’¾ Download File</button>

    <textarea id="log" readonly></textarea>
    
    <div class="preview-area">
        <canvas id="canvas"></canvas>
    </div>
</div>

<script>
// =============================================================================
// LOGIC: Backlash Compensator
// =============================================================================
class BacklashCompensator {
    constructor(bx, by) {
        this.bx = bx;
        this.by = by;
        this.threshold = 0.05;
        this.safeFeed = 200;
        
        this.currentX = 0.0;
        this.currentY = 0.0;
        this.offsetX = 0.0;
        this.offsetY = 0.0;
        this.dirX = 0; // 0=None, 1=Pos, -1=Neg
        this.dirY = 0;
    }

    processLines(lines) {
        let newGcode = [];
        
        // Regex to parse G-code
        const pX = /X([-\d\.]+)/;
        const pY = /Y([-\d\.]+)/;
        const pZ = /Z([-\d\.]+)/;
        const pF = /F([-\d\.]+)/;

        let currentFeed = 500.0;

        for (let line of lines) {
            let originalLine = line.trim();
            if (!originalLine || originalLine.startsWith(';')) {
                newGcode.push(originalLine);
                continue;
            }

            let targetX = this.currentX;
            let targetY = this.currentY;
            let targetZ = null;
            let hasMove = false;

            let mx = originalLine.match(pX);
            if (mx) { targetX = parseFloat(mx[1]); hasMove = true; }

            let my = originalLine.match(pY);
            if (my) { targetY = parseFloat(my[1]); hasMove = true; }

            let mz = originalLine.match(pZ);
            if (mz) { targetZ = parseFloat(mz[1]); }

            let mf = originalLine.match(pF);
            if (mf) { currentFeed = parseFloat(mf[1]); }

            if (!hasMove) {
                newGcode.push(originalLine);
                continue;
            }

            // --- X Axis Logic ---
            let dx = targetX - this.currentX;
            if (Math.abs(dx) > this.threshold) {
                let newDirX = dx > 0 ? 1 : -1;
                if (this.dirX !== 0 && newDirX !== this.dirX) {
                    let change = newDirX === 1 ? this.bx : -this.bx;
                    this.offsetX += change;
                    
                    let phyX = Math.max(0, this.currentX + this.offsetX);
                    let phyY = Math.max(0, this.currentY + this.offsetY);

                    newGcode.push(`; --- FIX X Backlash: ${change.toFixed(3)}mm ---`);
                    newGcode.push(`G0 X${phyX.toFixed(3)} Y${phyY.toFixed(3)} F${this.safeFeed}`);
                    newGcode.push(`G0 F${parseInt(currentFeed)}`);
                }
                this.dirX = newDirX;
            }

            // --- Y Axis Logic ---
            let dy = targetY - this.currentY;
            if (Math.abs(dy) > this.threshold) {
                let newDirY = dy > 0 ? 1 : -1;
                if (this.dirY !== 0 && newDirY !== this.dirY) {
                    let change = newDirY === 1 ? this.by : -this.by;
                    this.offsetY += change;

                    let phyX = Math.max(0, this.currentX + this.offsetX);
                    let phyY = Math.max(0, this.currentY + this.offsetY);

                    newGcode.push(`; --- FIX Y Backlash: ${change.toFixed(3)}mm ---`);
                    newGcode.push(`G0 X${phyX.toFixed(3)} Y${phyY.toFixed(3)} F${this.safeFeed}`);
                    newGcode.push(`G0 F${parseInt(currentFeed)}`);
                }
                this.dirY = newDirY;
            }

            // --- Reconstruct Line ---
            let finalX = Math.max(0, targetX + this.offsetX);
            let finalY = Math.max(0, targetY + this.offsetY);

            let cmd = originalLine.toUpperCase().includes("G0") ? "G0" : "G1";
            let out = `${cmd} X${finalX.toFixed(3)} Y${finalY.toFixed(3)}`;
            
            if (targetZ !== null) out += ` Z${targetZ.toFixed(3)}`;
            if (cmd === "G1") out += ` F${parseInt(currentFeed)}`;

            newGcode.push(out);

            this.currentX = targetX;
            this.currentY = targetY;
        }

        return newGcode;
    }
}

// =============================================================================
// LOGIC: Raster Generator
// =============================================================================
class RasterGenerator {
    constructor(params) {
        this.p = params;
        this.gcode = [];
        
        // Z heights adjustment
        this.zSafe = this.p.zSafe + this.p.zGlobal;
        this.zSafeDip = this.p.zSafeDip + this.p.zGlobal;
        this.zWipeTravel = this.p.zWipe + this.p.zGlobal;
        this.dipLocation = {
            x: this.p.dipX,
            y: this.p.dipY,
            z: this.p.dipZ + this.p.zGlobal
        };

        this.trayEnterRadius = this.p.wipeRadius > 0 ? this.p.wipeRadius * 0.3 : 0;
        this.distSinceLastDip = 0.0;
        this.currentX = this.p.xOffset;
        this.currentY = this.p.yOffset;
    }

    log(msg) {
        const logEl = document.getElementById("log");
        logEl.value += msg + "\n";
        logEl.scrollTop = logEl.scrollHeight;
    }

    removeDrops(trayX, trayY, x, y) {
        let dx = x - trayX;
        let dy = y - trayY;
        let dist = Math.hypot(dx, dy);
        let baseAngle = (dist === 0) ? 0.0 : Math.atan2(dy, dx);

        // Random variation +/- 12 degrees
        let variation = (Math.random() * 24 - 12) * (Math.PI / 180);
        let angle = baseAngle + variation;

        let ux = Math.cos(angle);
        let uy = Math.sin(angle);

        let x1 = trayX + ux * this.trayEnterRadius;
        let y1 = trayY + uy * this.trayEnterRadius;
        let x2 = trayX + ux * this.p.wipeRadius;
        let y2 = trayY + uy * this.p.wipeRadius;

        this.gcode.push(`; remove_drops angle=${(angle * 180/Math.PI).toFixed(1)}`);
        this.gcode.push(`G0 X${x1.toFixed(3)} Y${y1.toFixed(3)}`);
        this.gcode.push(`G0 Z${this.zWipeTravel.toFixed(3)}`);
        this.gcode.push(`G1 F600`);
        this.gcode.push(`G1 X${x2.toFixed(3)} Y${y2.toFixed(3)}`);
        this.gcode.push(`G0 F${this.p.feedRate}`);
    }

    performDip(targetX, targetY) {
        this.gcode.push("; --- Dip Cycle ---");
        this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)}`);
        this.gcode.push(`G0 X${this.dipLocation.x.toFixed(3)} Y${this.dipLocation.y.toFixed(3)}`);
        
        // Dip
        this.gcode.push(`G1 Z${this.dipLocation.z.toFixed(3)} F800`);
        if (this.p.dipDuration > 0) {
            this.gcode.push(`G4 P${this.p.dipDuration.toFixed(1)}`);
        }

        // Lift to wipe height
        this.gcode.push(`G1 Z${this.zWipeTravel.toFixed(3)} F800`);

        let tx = (targetX === null) ? this.dipLocation.x + this.p.wipeRadius : targetX;
        let ty = (targetY === null) ? this.dipLocation.y : targetY;

        if (this.p.removeDrops && this.p.wipeRadius > 0) {
            this.removeDrops(this.dipLocation.x, this.dipLocation.y, tx, ty);
        }

        this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)} F${this.p.feedRate}`);
        this.gcode.push("; --- End Dip ---");
        this.distSinceLastDip = 0.0;
    }

    process(imgData, widthPx, heightPx) {
        this.log("Starting generation...");
        this.gcode = [];

        // Headers
        this.gcode.push("G90");
        this.gcode.push("G21");
        this.gcode.push(`G0 Z${this.zSafe.toFixed(3)}`);
        this.gcode.push(`G0 F${this.p.feedRate}`);

        if (this.p.dipThreshold > 0) {
            this.log("Performing initial dip...");
            this.performDip(null, null);
        }

        this.gcode.push(`G0 X${this.p.xOffset.toFixed(3)} Y${this.p.yOffset.toFixed(3)} Z${this.zSafe.toFixed(3)}`);

        // Dimensions
        let scaleFactor = this.p.width / widthPx;
        let calculatedHeightMm = heightPx * scaleFactor;

        let currentYmm = 0.0;
        let rowIndex = 0;

        // Main Loop
        while (currentYmm <= calculatedHeightMm) {
            
            // Map mm to pixels
            // FIX UPSIDE DOWN: CNC Y0 is Bottom. Image Y0 is Top.
            // To flip image correct for CNC, we read pixels from Bottom of image to Top.
            // Image Height - 1 - (mapped index)
            let rawYIndex = Math.round(currentYmm / scaleFactor);
            if (rawYIndex >= heightPx) break;
            
            // Inverting Y index to fix orientation
            let yPixelIndex = heightPx - 1 - rawYIndex;

            let currentYTarget = currentYmm + this.p.yOffset;

            // Travel Optimization
            let startXmm = (rowIndex % 2 === 0) ? 0.0 : (widthPx - 1) * scaleFactor;
            let startXTarget = startXmm + this.p.xOffset;

            // Pre-row Dip Check
            let dist = Math.hypot(startXTarget - this.currentX, currentYTarget - this.currentY);
            this.distSinceLastDip += dist;

            if (this.p.dipThreshold > 0 && this.distSinceLastDip >= this.p.dipThreshold) {
                this.performDip(startXTarget, currentYTarget);
            }

            // Move to Start
            this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)}`);
            this.gcode.push(`G0 X${startXTarget.toFixed(3)} Y${currentYTarget.toFixed(3)}`);
            this.currentX = startXTarget;
            this.currentY = currentYTarget;

            // Initial Z plunge
            let firstXIdx = (rowIndex % 2 === 0) ? 0 : widthPx - 1;
            let firstIntensity = this.getPixelIntensity(imgData, widthPx, firstXIdx, yPixelIndex);
            let initZ = -Math.abs(this.p.maxDepth) * (1 - (firstIntensity / 255.0)) + this.p.zGlobal;
            this.gcode.push(`G1 Z${initZ.toFixed(3)} F${this.p.feedRate}`);

            // Pixel Loop
            let xStart = (rowIndex % 2 === 0) ? 0 : widthPx - 1;
            let xEnd = (rowIndex % 2 === 0) ? widthPx : -1;
            let xStep = (rowIndex % 2 === 0) ? 1 : -1;

            for (let x = xStart; x !== xEnd; x += xStep) {
                let intensity = this.getPixelIntensity(imgData, widthPx, x, yPixelIndex);
                let zDepth = -Math.abs(this.p.maxDepth) * (1 - (intensity / 255.0)) + this.p.zGlobal;
                let curXmm = x * scaleFactor;
                let finalX = curXmm + this.p.xOffset;
                let finalY = this.currentY;

                let dMove = Math.abs(finalX - this.currentX);
                this.distSinceLastDip += dMove;

                this.gcode.push(`G1 X${finalX.toFixed(3)} Y${finalY.toFixed(3)} Z${zDepth.toFixed(3)}`);
                this.currentX = finalX;

                // Mid-row dip check
                if (this.p.dipThreshold > 0 && this.distSinceLastDip >= this.p.dipThreshold) {
                    this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)}`);
                    this.performDip(this.currentX, this.currentY);
                    this.gcode.push(`G0 X${this.currentX.toFixed(3)} Y${this.currentY.toFixed(3)}`);
                    this.gcode.push(`G1 Z${zDepth.toFixed(3)} F${this.p.feedRate}`);
                }
            }

            // Lift at end of row
            this.gcode.push(`G0 Z${this.zSafe.toFixed(3)}`);

            rowIndex++;
            currentYmm += this.p.lineSpacing;
        }

        // Footer
        this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)}`);
        this.gcode.push(`G0 X${this.p.xOffset.toFixed(3)} Y${this.p.yOffset.toFixed(3)}`);
        this.gcode.push("M2");

        this.log("Raster generation complete.");
        
        // BACKLASH PROCESSING
        if (this.p.bx > 0 || this.p.by > 0) {
            this.log(`Applying Backlash (X:${this.p.bx}, Y:${this.p.by})...`);
            const bl = new BacklashCompensator(this.p.bx, this.p.by);
            this.gcode = bl.processLines(this.gcode);
        }

        this.log("Finished.");
        return this.gcode.join("\n");
    }

    getPixelIntensity(imgData, width, x, y) {
        // imgData is RGBA. Index = (y * width + x) * 4
        let idx = (y * width + x) * 4;
        let r = imgData[idx];
        let g = imgData[idx + 1];
        let b = imgData[idx + 2];
        return (r + g + b) / 3.0;
    }
}

// =============================================================================
// UI HANDLERS
// =============================================================================
let finalGCodeText = "";

document.getElementById('imageInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if(file){
        document.getElementById('fileName').textContent = file.name;
        const reader = new FileReader();
        reader.onload = function(evt) {
            const img = new Image();
            img.onload = function() {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
            }
            img.src = evt.target.result;
        }
        reader.readAsDataURL(file);
    }
});

function generateGCode() {
    const canvas = document.getElementById('canvas');
    if (canvas.width === 0) {
        alert("Please load an image first.");
        return;
    }

    const ctx = canvas.getContext('2d');
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

    // Gather Parameters
    const params = {
        width: parseFloat(document.getElementById('width').value),
        maxDepth: parseFloat(document.getElementById('maxDepth').value),
        lineSpacing: parseFloat(document.getElementById('lineSpacing').value),
        feedRate: parseFloat(document.getElementById('feedRate').value),
        xOffset: parseFloat(document.getElementById('xOffset').value),
        yOffset: parseFloat(document.getElementById('yOffset').value),
        dipThreshold: parseFloat(document.getElementById('dipThreshold').value),
        dipX: parseFloat(document.getElementById('dipX').value),
        dipY: parseFloat(document.getElementById('dipY').value),
        dipZ: parseFloat(document.getElementById('dipZ').value),
        dipDuration: parseFloat(document.getElementById('dipDuration').value),
        wipeRadius: parseFloat(document.getElementById('wipeRadius').value),
        removeDrops: document.getElementById('removeDrops').checked,
        zSafe: parseFloat(document.getElementById('zSafe').value),
        zSafeDip: parseFloat(document.getElementById('zSafeDip').value),
        zWipe: parseFloat(document.getElementById('zWipe').value),
        zGlobal: parseFloat(document.getElementById('zGlobal').value),
        bx: parseFloat(document.getElementById('bx').value),
        by: parseFloat(document.getElementById('by').value)
    };

    document.getElementById('log').value = "";
    const generator = new RasterGenerator(params);
    
    // Use setTimeout to allow UI to update before processing hangs the main thread
    setTimeout(() => {
        finalGCodeText = generator.process(imgData, canvas.width, canvas.height);
        document.getElementById('downloadBtn').style.display = 'block';
    }, 100);
}

function downloadGCode() {
    const blob = new Blob([finalGCodeText], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "watercolor.gcode";
    a.click();
    window.URL.revokeObjectURL(url);
}
</script>

</body>
</html>