<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bacterial Painter · G-code Generator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Mono:wght@400;700&display=swap');
        
        :root {
            --bg-dark: #0a0e14;
            --bg-mid: #151922;
            --bg-light: #1f2430;
            --accent-cyan: #00d4ff;
            --accent-pink: #ff2e97;
            --accent-yellow: #ffd700;
            --text-bright: #e6edf3;
            --text-dim: #8b949e;
            --border: #30363d;
            --success: #3fb950;
            --danger: #f85149;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Space Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-bright);
            overflow-x: hidden;
            line-height: 1.6;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 212, 255, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 46, 151, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }
        
        .container {
            position: relative;
            z-index: 1;
            max-width: 1800px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        header {
            text-align: center;
            padding: 3rem 0;
            border-bottom: 2px solid var(--border);
            margin-bottom: 3rem;
        }
        
        h1 {
            font-size: 3.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
        }
        
        .subtitle {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-dim);
            font-size: 0.95rem;
            letter-spacing: 0.05em;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 2rem;
        }
        
        .panel {
            background: var(--bg-mid);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .panel-title {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--accent-cyan);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .panel-title::before {
            content: '▸';
            color: var(--accent-cyan);
            font-size: 1.5rem;
        }
        
        .controls-panel {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .controls-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .controls-panel::-webkit-scrollbar-track {
            background: var(--bg-dark);
            border-radius: 4px;
        }
        
        .controls-panel::-webkit-scrollbar-thumb {
            background: var(--accent-cyan);
            border-radius: 4px;
        }
        
        .control-section {
            margin-bottom: 2rem;
            transition: opacity 0.3s ease;
        }
        
        .control-section.disabled {
            opacity: 0.4;
            pointer-events: none;
        }
        
        .section-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-pink);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        
        .control-group {
            margin-bottom: 1.25rem;
        }
        
        label {
            display: block;
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        input[type="number"],
        input[type="file"],
        select {
            width: 100%;
            background: var(--bg-light);
            border: 1px solid var(--border);
            color: var(--text-bright);
            padding: 0.75rem;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
        }
        
        input[type="file"] {
            cursor: pointer;
            padding: 1rem;
        }
        
        input[type="file"]::file-selector-button {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-pink));
            border: none;
            color: var(--bg-dark);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            margin-right: 1rem;
        }
        
        button {
            width: 100%;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-pink));
            border: none;
            color: var(--bg-dark);
            padding: 1rem 2rem;
            border-radius: 8px;
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 1rem;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 212, 255, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .preview-panel {
            position: relative;
            min-height: 600px;
        }
        
        .preview-container {
            width: 100%;
            min-height: 400px;
            background: var(--bg-light);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .placeholder {
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
        }
        
        #previewCanvas,
        #gcodeCanvas {
            max-width: 100%;
            border-radius: 8px;
            display: none;
        }
        
        .stats-overlay {
            position: absolute;
            top: 2rem;
            right: 2rem;
            background: rgba(10, 14, 20, 0.9);
            border: 1px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            display: none;
            backdrop-filter: blur(10px);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .stat-label {
            color: var(--text-dim);
        }
        
        .stat-value {
            color: var(--accent-cyan);
            font-weight: 600;
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 20, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .hidden {
            display: none !important;
        }
        
        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--border);
            border-top-color: var(--accent-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .info-text {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-top: 0.25rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .highlight {
            color: var(--accent-yellow);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>BACTERIAL PAINTER</h1>
            <div class="subtitle">G-CODE GENERATOR FOR PRECISION BIOART</div>
        </header>
        
        <div class="main-grid">
            <div class="panel controls-panel">
                <div class="panel-title">Configuration</div>
                
                <div class="control-section">
                    <div class="section-header">Image Input</div>
                    <div class="control-group">
                        <label for="imageUpload">Upload Image</label>
                        <input type="file" id="imageUpload" accept="image/*">
                        <div class="info-text">Supports PNG, JPG, WebP</div>
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="section-header">Generation Mode</div>
                    <div class="control-group">
                        <label for="mode">Mode</label>
                        <select id="mode">
                            <option value="paint">Paint (with dipping)</option>
                            <option value="plot">Plot (continuous)</option>
                        </select>
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="section-header">Infill Settings</div>
                    <div class="control-group">
                        <label for="infillType">Infill Type</label>
                        <select id="infillType">
                            <option value="linear">Linear</option>
                            <option value="concentric">Concentric</option>
                        </select>
                    </div>
                    <div class="control-group" id="angleGroup">
                        <label for="infillAngle">Infill Angle (degrees)</label>
                        <input type="number" id="infillAngle" value="0" step="1" min="-180" max="180">
                        <div class="info-text">Only for linear infill</div>
                    </div>
                    <div class="control-group">
                        <label for="resolution">Resolution (px/mm) <span class="highlight">★</span></label>
                        <input type="number" id="resolution" value="2.0" step="0.1" min="0.5" max="10">
                        <div class="info-text">Higher = more detail</div>
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="section-header">Dimensions</div>
                    <div class="control-group">
                        <label for="targetWidth">Target Width (mm)</label>
                        <input type="number" id="targetWidth" value="50" step="1" min="1">
                    </div>
                    <div class="control-group">
                        <label for="brushW">Brush Width (mm)</label>
                        <input type="number" id="brushW" value="1.0" step="0.1" min="0.1">
                    </div>
                    <div class="control-group">
                        <label for="overlap">Line Overlap (0-1)</label>
                        <input type="number" id="overlap" value="0.2" step="0.05" min="0" max="0.9">
                    </div>
                </div>
                
                <div class="control-section" id="dippingSection">
                    <div class="section-header">Dipping Parameters</div>
                    <div class="control-group">
                        <label for="minDist">Min Distance Before Dip (mm)</label>
                        <input type="number" id="minDist" value="30" step="1" min="1">
                    </div>
                    <div class="control-group">
                        <label for="maxDist">Max Distance Before Dip (mm)</label>
                        <input type="number" id="maxDist" value="50" step="1" min="1">
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="section-header">Z Heights</div>
                    <div class="control-group">
                        <label for="zPaint">Paint Height (mm)</label>
                        <input type="number" id="zPaint" value="0.0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label for="zLow">Low Height (mm)</label>
                        <input type="number" id="zLow" value="2.0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label for="zHigh">High Height (mm)</label>
                        <input type="number" id="zHigh" value="10.0" step="0.1">
                    </div>
                    <div class="control-group" id="dipZGroup">
                        <label for="dipZ">Dip Depth (mm)</label>
                        <input type="number" id="dipZ" value="-5.0" step="0.1">
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="section-header">Offsets</div>
                    <div class="control-group">
                        <label for="xOff">X Offset (mm)</label>
                        <input type="number" id="xOff" value="0" step="1">
                    </div>
                    <div class="control-group">
                        <label for="yOff">Y Offset (mm)</label>
                        <input type="number" id="yOff" value="0" step="1">
                    </div>
                </div>
                
                <div class="control-section" id="dipStationSection">
                    <div class="section-header">Dip Station</div>
                    <div class="control-group">
                        <label for="dipX">Dip X Position (mm)</label>
                        <input type="number" id="dipX" value="100" step="1">
                    </div>
                    <div class="control-group">
                        <label for="dipY">Dip Y Position (mm)</label>
                        <input type="number" id="dipY" value="100" step="1">
                    </div>
                    <div class="control-group">
                        <label for="dipJitter">Dip Jitter (mm)</label>
                        <input type="number" id="dipJitter" value="2.0" step="0.1" min="0">
                    </div>
                    <div class="control-group">
                        <label for="dipSpiralR">Dip Spiral Radius (mm)</label>
                        <input type="number" id="dipSpiralR" value="3.0" step="0.1" min="0">
                    </div>
                    <div class="control-group">
                        <label for="wipeR">Wipe Radius (mm)</label>
                        <input type="number" id="wipeR" value="5.0" step="0.1" min="0">
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="section-header">Speed & Acceleration</div>
                    <div class="control-group">
                        <label for="feed">Travel Feed Rate (mm/s)</label>
                        <input type="number" id="feed" value="100" step="10" min="1">
                    </div>
                    <div class="control-group">
                        <label for="feedPaint">Paint Feed Rate (mm/s)</label>
                        <input type="number" id="feedPaint" value="50" step="5" min="1">
                    </div>
                    <div class="control-group">
                        <label for="accelTravel">Travel Acceleration (mm/s²)</label>
                        <input type="number" id="accelTravel" value="1000" step="100" min="10">
                    </div>
                    <div class="control-group">
                        <label for="accelPaint">Paint Acceleration (mm/s²)</label>
                        <input type="number" id="accelPaint" value="500" step="50" min="10">
                    </div>
                </div>
                
                <button id="generateBtn">Generate G-Code</button>
                <button id="downloadBtn" disabled>Download G-Code</button>
            </div>
            
            <div class="panel preview-panel">
                <div class="panel-title">Preview</div>
                <div class="preview-container" id="previewContainer">
                    <div class="placeholder" id="placeholder">Upload an image to begin</div>
                    <canvas id="previewCanvas"></canvas>
                    <canvas id="gcodeCanvas"></canvas>
                </div>
                <div class="stats-overlay" id="statsOverlay">
                    <div class="stat-row">
                        <span class="stat-label">G-code Lines:</span>
                        <span class="stat-value" id="statLines">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Paths:</span>
                        <span class="stat-value" id="statPaths">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Dips:</span>
                        <span class="stat-value" id="statDips">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Est. Time:</span>
                        <span class="stat-value" id="statTime">0 min</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="loading hidden" id="loading">
        <div class="spinner"></div>
    </div>
    
    <script>
        let currentImage = null;
        let generatedGCode = '';
        
        // Mode and infill type change handlers
        function updateUIState() {
            const isPlotMode = document.getElementById('mode').value === 'plot';
            const isLinear = document.getElementById('infillType').value === 'linear';
            
            document.getElementById('dippingSection').classList.toggle('disabled', isPlotMode);
            document.getElementById('dipStationSection').classList.toggle('disabled', isPlotMode);
            document.getElementById('dipZGroup').classList.toggle('disabled', isPlotMode);
            document.getElementById('angleGroup').classList.toggle('disabled', !isLinear);
        }
        
        document.getElementById('mode').addEventListener('change', updateUIState);
        document.getElementById('infillType').addEventListener('change', updateUIState);
        
        // Image upload handler
        document.getElementById('imageUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    currentImage = img;
                    
                    const canvas = document.getElementById('previewCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    const containerWidth = document.getElementById('previewContainer').offsetWidth;
                    const aspectRatio = img.height / img.width;
                    
                    canvas.width = Math.min(containerWidth - 40, img.width);
                    canvas.height = canvas.width * aspectRatio;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    document.getElementById('placeholder').classList.add('hidden');
                    canvas.style.display = 'block';
                    document.getElementById('gcodeCanvas').style.display = 'none';
                    document.getElementById('statsOverlay').style.display = 'none';
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
        
        // G-code Generator
        class GCodePainter {
            constructor(cfg) {
                this.cfg = cfg;
                this.gcode = [];
                this.currentPos = [0, 0];
                this.distSinceDip = 0;
                this.currentMaxDist = 0;
                this.dipCount = 0;
                this.paths = [];
                this.imgHeightMM = 0;
            }
            
            randomRange(min, max) {
                return min + Math.random() * (max - min);
            }
            
            updatePos(x, y) {
                this.currentPos = [x, y];
            }
            
            generate(imgData, width, height) {
                const res = this.cfg.resolution;
                this.imgHeightMM = this.cfg.targetWidth * (height / width);
                
                if (this.cfg.infillType === 'concentric') {
                    this.paths = this.generateConcentric(imgData, width, height, res);
                } else {
                    this.paths = this.generateLinear(imgData, width, height, res);
                }
                
                this.paths = this.optimizePaths(this.paths);
                
                if (this.cfg.mode === 'plot') {
                    return this.generatePlotGCode();
                } else {
                    return this.generatePaintGCode();
                }
            }
            
            // Helper to get Final Coordinates (Flipped Y + Offsets)
            getRealCoords(x, y) {
                return [
                    x + this.cfg.xOff, 
                    (this.imgHeightMM - y) + this.cfg.yOff
                ];
            }
            
            generateLinear(imgData, width, height, res) {
                const c = this.cfg;
                const targetW = c.targetWidth;
                const targetH = this.imgHeightMM;
                const angle = c.infillAngle * Math.PI / 180;
                const step = c.brushW * (1 - c.overlap);
                const diag = Math.hypot(targetW, targetH);
                const paths = [];
                
                const numLines = Math.ceil(diag / step);
                
                for (let i = -numLines; i <= numLines; i++) {
                    const offset = i * step;
                    let path = [];
                    
                    for (let d = -diag; d <= diag; d += 1/res) {
                        const cx = targetW / 2;
                        const cy = targetH / 2;
                        
                        const x = (d - cx) * Math.cos(angle) - (offset - cy) * Math.sin(angle) + cx;
                        const y = (d - cx) * Math.sin(angle) + (offset - cy) * Math.cos(angle) + cy;
                        
                        const px = Math.floor(x * res);
                        const py = Math.floor(y * res);
                        
                        if (px >= 0 && px < width && py >= 0 && py < height) {
                            const idx = (py * width + px) * 4;
                            if (imgData.data[idx] < 140) {
                                // Store Image Space Coords (no offset yet)
                                path.push([y, x]);
                            } else {
                                if (path.length > 2) paths.push(path);
                                path = [];
                            }
                        } else {
                            if (path.length > 2) paths.push(path);
                            path = [];
                        }
                    }
                    if (path.length > 2) paths.push(path);
                }
                
                return paths;
            }
            
            generateConcentric(imgData, width, height, res) {
                const c = this.cfg;
                
                // Convert to binary flat array for performance
                const len = width * height;
                const binary = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    binary[i] = imgData.data[i * 4] < 140 ? 1 : 0;
                }
                
                const paths = [];
                const erosionStep = Math.max(1, Math.round(c.brushW * (1 - c.overlap) * res));
                let currentBinary = binary;
                let layer = 0;

                // Loop to create concentric rings
                while (layer < 500) { // Safety limit
                    // 1. Find all edge pixels
                    const edgeData = this.findEdges(currentBinary, width, height);
                    if (edgeData.count === 0) break;

                    // 2. Trace distinct loops
                    const loops = this.traceLoops(edgeData, width, height);
                    
                    // 3. Convert loops to physical coordinates (Image Space)
                    for (const loop of loops) {
                        if (loop.length < 3) continue;
                        
                        const physPath = loop.map(idx => {
                            const y = Math.floor(idx / width);
                            const x = idx % width;
                            return [
                                y / res, // Raw Y (Top-down)
                                x / res  // Raw X
                            ];
                        });
                        paths.push(physPath);
                    }

                    // 4. Erode
                    currentBinary = this.erode(currentBinary, width, height, erosionStep);
                    layer++;
                }
                
                return paths;
            }

            findEdges(binary, width, height) {
                const map = new Uint8Array(width * height);
                let count = 0;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = y * width + x;
                        if (binary[idx] === 1) {
                            let isEdge = false;
                            if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {
                                isEdge = true;
                            } else if (
                                binary[idx - 1] === 0 || 
                                binary[idx + 1] === 0 || 
                                binary[idx - width] === 0 || 
                                binary[idx + width] === 0
                            ) {
                                isEdge = true;
                            }
                            
                            if (isEdge) {
                                map[idx] = 1;
                                count++;
                            }
                        }
                    }
                }
                return { map, count };
            }

            traceLoops(edgeData, width, height) {
                const loops = [];
                const map = edgeData.map;
                const visited = new Uint8Array(width * height);
                
                const getValidNeighbors = (idx) => {
                    const cx = idx % width;
                    const cy = Math.floor(idx / width);
                    const n = [];
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const nx = cx + dx;
                            const ny = cy + dy;
                            
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const nIdx = ny * width + nx;
                                if (map[nIdx] === 1 && visited[nIdx] === 0) {
                                    n.push(nIdx);
                                }
                            }
                        }
                    }
                    return n;
                };

                for (let i = 0; i < map.length; i++) {
                    if (map[i] === 1 && visited[i] === 0) {
                        const loop = [i];
                        visited[i] = 1;
                        let curr = i;
                        let found = true;
                        
                        while (found) {
                            found = false;
                            const neighbors = getValidNeighbors(curr);
                            
                            if (neighbors.length > 0) {
                                const next = neighbors[0];
                                visited[next] = 1;
                                loop.push(next);
                                curr = next;
                                found = true;
                            }
                        }
                        loops.push(loop);
                    }
                }
                return loops;
            }
            
            erode(binary, width, height, amount) {
                const result = new Uint8Array(width * height);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = y * width + x;
                        if (binary[idx] === 1) {
                            let keep = true;
                            checkLoop:
                            for (let dy = -amount; dy <= amount; dy++) {
                                for (let dx = -amount; dx <= amount; dx++) {
                                    const ny = y + dy;
                                    const nx = x + dx;
                                    
                                    if (ny < 0 || ny >= height || nx < 0 || nx >= width) {
                                        keep = false;
                                        break checkLoop;
                                    }
                                    if (binary[ny * width + nx] === 0) {
                                        keep = false;
                                        break checkLoop;
                                    }
                                }
                            }
                            if (keep) result[idx] = 1;
                        }
                    }
                }
                return result;
            }
            
            optimizePaths(paths) {
                if (paths.length <= 1) return paths;
                
                const optimized = [paths[0]];
                const remaining = paths.slice(1);
                
                while (remaining.length > 0) {
                    const lastPath = optimized[optimized.length - 1];
                    const lastPt = lastPath[lastPath.length - 1];
                    
                    let minDist = Infinity;
                    let minIdx = 0;
                    let reverseNext = false;
                    
                    for (let i = 0; i < remaining.length; i++) {
                        const startPt = remaining[i][0];
                        const endPt = remaining[i][remaining[i].length - 1];
                        
                        const dStart = Math.hypot(startPt[0] - lastPt[0], startPt[1] - lastPt[1]);
                        const dEnd = Math.hypot(endPt[0] - lastPt[0], endPt[1] - lastPt[1]);
                        
                        if (dStart < minDist) {
                            minDist = dStart;
                            minIdx = i;
                            reverseNext = false;
                        }
                        if (dEnd < minDist) {
                            minDist = dEnd;
                            minIdx = i;
                            reverseNext = true;
                        }
                    }
                    
                    const nextPath = remaining[minIdx];
                    if (reverseNext) nextPath.reverse();
                    
                    optimized.push(nextPath);
                    remaining.splice(minIdx, 1);
                }
                
                return optimized;
            }
            
            generatePlotGCode() {
                const c = this.cfg;
                this.gcode = ["G21", "G90", "G0 Z10"];
                this.setSpeed('travel');
                
                for (const path of this.paths) {
                    if (path.length === 0) continue;
                    
                    // Apply offsets and Flip Y
                    const [sx, sy] = this.getRealCoords(path[0][1], path[0][0]);
                    
                    this.gcode.push(`G0 X${sx.toFixed(3)} Y${sy.toFixed(3)}`);
                    this.gcode.push(`G1 Z${c.zPaint.toFixed(3)}`);
                    
                    for (let i = 1; i < path.length; i++) {
                        const [px, py] = this.getRealCoords(path[i][1], path[i][0]);
                        this.gcode.push(`G1 X${px.toFixed(3)} Y${py.toFixed(3)}`);
                    }
                    
                    this.gcode.push(`G0 Z${c.zLow}`);
                }
                
                this.gcode.push("M2");
                return this.gcode.join('\n');
            }
            
            generatePaintGCode() {
                const c = this.cfg;
                this.gcode = ["G21", "G90"];
                this.currentMaxDist = this.randomRange(c.minDist, c.maxDist);
                
                this.setSpeed('travel');
                this.gcode.push(`G0 Z${c.zHigh}`);
                
                if (this.paths.length > 0) {
                   const [tx, ty] = this.getRealCoords(this.paths[0][0][1], this.paths[0][0][0]);
                   this.dip(tx, ty);
                }
                
                for (const path of this.paths) {
                    if (path.length === 0) continue;

                    const [sx, sy] = this.getRealCoords(path[0][1], path[0][0]);
                    
                    const dist = Math.hypot(
                        this.currentPos[0] - sx,
                        this.currentPos[1] - sy
                    );
                    
                    if (dist > 0.5) {
                        this.setSpeed('travel');
                        this.gcode.push(`G0 X${sx.toFixed(3)} Y${sy.toFixed(3)} Z${c.zLow}`);
                        this.updatePos(sx, sy);
                    }
                    
                    for (let i = 1; i < path.length; i++) {
                        const [px, py] = this.getRealCoords(path[i][1], path[i][0]);
                        const segLen = Math.hypot(px - this.currentPos[0], py - this.currentPos[1]);
                        
                        if (this.distSinceDip + segLen > this.currentMaxDist) {
                            this.dip(px, py);
                        }
                        
                        this.setSpeed('paint');
                        this.gcode.push(`G1 Z${c.zPaint.toFixed(3)}`);
                        this.gcode.push(`G1 X${px.toFixed(3)} Y${py.toFixed(3)}`);
                        this.distSinceDip += segLen;
                        this.updatePos(px, py);
                    }
                    
                    this.gcode.push(`G0 Z${c.zLow}`);
                }
                
                this.gcode.push("M2");
                return this.gcode.join('\n');
            }
            
            setSpeed(type) {
                const c = this.cfg;
                const f = type === 'travel' ? c.feed : c.feedPaint;
                const a = type === 'travel' ? c.accelTravel : c.accelPaint;
                this.gcode.push("M400", `M204 P${a} T${a}`, `M203 X${f} Y${f} Z${f}`, `G0 F${f}`);
            }
            
            dip(tx, ty) {
                const c = this.cfg;
                this.setSpeed('travel');
                
                const jx = this.randomRange(-c.dipJitter, c.dipJitter);
                const jy = this.randomRange(-c.dipJitter, c.dipJitter);
                const dx = c.dipX + jx;
                const dy = c.dipY + jy;
                
                this.gcode.push(`G0 X${dx.toFixed(3)} Y${dy.toFixed(3)} Z${c.zHigh}`);
                
                this.setSpeed('paint');
                this.gcode.push(`G1 Z${c.dipZ}`);
                
                const dir = (this.dipCount++ % 2) ? 1 : -1;
                for (let t = 0; t <= 2.5 * Math.PI; t += 0.1) {
                    const r = (t / (2.5 * Math.PI)) * c.dipSpiralR;
                    this.gcode.push(`G1 X${(dx + r * Math.cos(t * dir)).toFixed(3)} Y${(dy + r * Math.sin(t * dir)).toFixed(3)}`);
                }
                
                this.setSpeed('travel');
                this.gcode.push(`G0 Z${c.zHigh}`);
                
                const angle = Math.atan2(ty - c.dipY, tx - c.dipX);
                this.gcode.push(`G0 X${(c.dipX + c.wipeR * Math.cos(angle)).toFixed(3)} Y${(c.dipY + c.wipeR * Math.sin(angle)).toFixed(3)} Z${c.zHigh}`);
                this.gcode.push(`G0 X${tx.toFixed(3)} Y${ty.toFixed(3)} Z${c.zLow}`);
                
                this.distSinceDip = 0;
                this.currentMaxDist = this.randomRange(c.minDist, c.maxDist);
                this.updatePos(tx, ty);
            }
        }
        
        // Visualization
        function visualize(gcode, paths, mode) {
            const canvas = document.getElementById('gcodeCanvas');
            const ctx = canvas.getContext('2d');
            
            const container = document.getElementById('previewContainer');
            canvas.width = container.offsetWidth - 40;
            canvas.height = 600;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!paths || paths.length === 0) return;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            paths.forEach(p => p.forEach(pt => {
                minX = Math.min(minX, pt[1]);
                minY = Math.min(minY, pt[0]);
                maxX = Math.max(maxX, pt[1]);
                maxY = Math.max(maxY, pt[0]);
            }));
            
            const margin = 40;
            // Prevent division by zero if single point
            const w = maxX - minX || 1;
            const h = maxY - minY || 1;
            
            const sx = (canvas.width - margin * 2) / w;
            const sy = (canvas.height - margin * 2) / h;
            const scale = Math.min(sx, sy);
            
            const ox = margin - minX * scale + (canvas.width - margin * 2 - w * scale) / 2;
            const oy = margin - minY * scale + (canvas.height - margin * 2 - h * scale) / 2;
            
            // Travel moves
            ctx.strokeStyle = 'rgba(0, 212, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            for (let i = 0; i < paths.length - 1; i++) {
                const e = paths[i][paths[i].length - 1];
                const s = paths[i + 1][0];
                ctx.beginPath();
                ctx.moveTo(e[1] * scale + ox, e[0] * scale + oy);
                ctx.lineTo(s[1] * scale + ox, s[0] * scale + oy);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // Paths
            paths.forEach((path, i) => {
                ctx.beginPath();
                ctx.strokeStyle = `hsl(${(i / paths.length) * 360}, 80%, 60%)`;
                ctx.lineWidth = 2;
                
                path.forEach((pt, j) => {
                    const x = pt[1] * scale + ox;
                    const y = pt[0] * scale + oy;
                    j === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                });
                ctx.stroke();
            });
            
            document.getElementById('statLines').textContent = gcode.split('\n').length;
            document.getElementById('statPaths').textContent = paths.length;
            document.getElementById('statDips').textContent = mode === 'plot' ? 'N/A' : (gcode.match(/G4 P300/g) || []).length;
            document.getElementById('statTime').textContent = Math.ceil(gcode.split('\n').length / 20) + ' min';
            document.getElementById('statsOverlay').style.display = 'block';
        }
        
        // Generate
        document.getElementById('generateBtn').addEventListener('click', async function() {
            if (!currentImage) {
                alert('Please upload an image first');
                return;
            }
            
            document.getElementById('loading').classList.remove('hidden');
            await new Promise(r => setTimeout(r, 100));
            
            try {
                const config = {
                    mode: document.getElementById('mode').value,
                    infillType: document.getElementById('infillType').value,
                    infillAngle: parseFloat(document.getElementById('infillAngle').value),
                    resolution: parseFloat(document.getElementById('resolution').value),
                    targetWidth: parseFloat(document.getElementById('targetWidth').value),
                    brushW: parseFloat(document.getElementById('brushW').value),
                    overlap: parseFloat(document.getElementById('overlap').value),
                    minDist: parseFloat(document.getElementById('minDist').value),
                    maxDist: parseFloat(document.getElementById('maxDist').value),
                    zPaint: parseFloat(document.getElementById('zPaint').value),
                    zLow: parseFloat(document.getElementById('zLow').value),
                    zHigh: parseFloat(document.getElementById('zHigh').value),
                    dipZ: parseFloat(document.getElementById('dipZ').value),
                    xOff: parseFloat(document.getElementById('xOff').value),
                    yOff: parseFloat(document.getElementById('yOff').value),
                    dipX: parseFloat(document.getElementById('dipX').value),
                    dipY: parseFloat(document.getElementById('dipY').value),
                    dipJitter: parseFloat(document.getElementById('dipJitter').value),
                    dipSpiralR: parseFloat(document.getElementById('dipSpiralR').value),
                    wipeR: parseFloat(document.getElementById('wipeR').value),
                    feed: parseFloat(document.getElementById('feed').value),
                    feedPaint: parseFloat(document.getElementById('feedPaint').value),
                    accelTravel: parseFloat(document.getElementById('accelTravel').value),
                    accelPaint: parseFloat(document.getElementById('accelPaint').value)
                };
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const w = Math.floor(config.targetWidth * config.resolution);
                const h = Math.floor(w * (currentImage.height / currentImage.width));
                
                canvas.width = w;
                canvas.height = h;
                ctx.drawImage(currentImage, 0, 0, w, h);
                
                const imgData = ctx.getImageData(0, 0, w, h);
                
                const painter = new GCodePainter(config);
                generatedGCode = painter.generate(imgData, w, h);
                
                document.getElementById('previewCanvas').style.display = 'none';
                document.getElementById('gcodeCanvas').style.display = 'block';
                visualize(generatedGCode, painter.paths, config.mode);
                
                document.getElementById('downloadBtn').disabled = false;
            } catch (error) {
                console.error('Error:', error);
                alert('Error: ' + error.message);
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        });
        
        // Download
        document.getElementById('downloadBtn').addEventListener('click', function() {
            if (!generatedGCode) return;
            const blob = new Blob([generatedGCode], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'bacterial_painter.gcode';
            a.click();
            URL.revokeObjectURL(url);
        });
    </script>
</body>
</html>