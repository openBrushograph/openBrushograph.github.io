<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Variable Depth pen Ploter </title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #f4f4f9; padding: 20px; color: #333; }
        .container { max-width: 900px; margin: 0 auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h1 { margin-top: 0; color: #2c3e50; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .section { background: #fafafa; padding: 15px; border-radius: 6px; border: 1px solid #eee; }
        .section h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.1em; color: #2980b9; border-bottom: 2px solid #ddd; padding-bottom: 5px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; font-size: 0.9em; }
        input[type="number"], input[type="text"] { width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        .checkbox-group { display: flex; align-items: center; margin-bottom: 10px; }
        .checkbox-group input { width: auto; margin-right: 10px; }
        button { background: #8e44ad; color: white; border: none; padding: 12px 20px; font-size: 16px; border-radius: 4px; cursor: pointer; width: 100%; margin-top: 10px; transition: background 0.3s; }
        button:hover { background: #732d91; }
        #log { width: 100%; height: 150px; background: #222; color: #0f0; font-family: monospace; padding: 10px; border-radius: 4px; overflow-y: scroll; box-sizing: border-box; margin-top: 20px; font-size: 12px; }
        canvas { display: none; }
        .preview-area { margin-top: 20px; text-align: center; }
        .preview-area img { max-width: 100%; border: 1px solid #ddd; }
        .file-input { background: #ecf0f1; padding: 20px; text-align: center; border: 2px dashed #bdc3c7; border-radius: 6px; cursor: pointer; }
    </style>
</head>
<body>

<div class="container">
    <h1>Continuous Line Painter</h1>
    
    <div class="file-input">
        <label for="imageInput" style="cursor: pointer;">üñºÔ∏è Click to Select Image</label>
        <input type="file" id="imageInput" accept="image/*" style="display:none">
        <div id="fileName">No file selected</div>
    </div>

    <div class="grid">
        <div class="section">
            <h3>üé® Painting Parameters</h3>
            <label>Output Width (mm)</label>
            <input type="number" id="width" value="120.0" step="0.1">
            <label>Max Depth (Z mm, negative)</label>
            <input type="number" id="maxDepth" value="-1.0" step="0.1">
            <label>**Dip Intensity Threshold (0-255)**</label>
            <input type="number" id="dipIntensityThreshold" value="150" step="1">
            <label>Feed Rate (mm/min)</label>
            <input type="number" id="feedRate" value="1500">
            <label>X Offset (mm)</label>
            <input type="number" id="xOffset" value="0.0">
            <label>Y Offset (mm)</label>
            <input type="number" id="yOffset" value="0.0">
        </div>

        <div class="section">
            <h3>üö∞ Dipping & Wiping</h3>
            <label>Dip Trigger Distance (mm)</label>
            <input type="number" id="dipThreshold" value="5000000000.0">
            <div class="grid" style="grid-template-columns: 1fr 1fr 1fr; gap: 5px; margin-bottom: 0;">
                <div><label>Dip X</label><input type="number" id="dipX" value="0.0"></div>
                <div><label>Dip Y</label><input type="number" id="dipY" value="0.0"></div>
                <div><label>Dip Z</label><input type="number" id="dipZ" value="0.0"></div>
            </div>
            <label>Dip Duration (sec)</label>
            <input type="number" id="dipDuration" value="0.001" step="0.1">
            <label>Wipe Radius (mm)</label>
            <input type="number" id="wipeRadius" value="0.0">
            <div class="checkbox-group">
                <input type="checkbox" id="removeDrops" checked>
                <label for="removeDrops">Enable Wipe/Shake</label>
            </div>
        </div>

        <div class="section">
            <h3>üìê Z Heights & Backlash</h3>
            <label>Safe Z (Travel)</label>
            <input type="number" id="zSafe" value="2.0">
            <label>Safe Z (Dip Travel)</label>
            <input type="number" id="zSafeDip" value="2.0">
            <label>Wipe Height (Z)</label>
            <input type="number" id="zWipe" value="2.0">
            <label>Global Z Offset</label>
            <input type="number" id="zGlobal" value="0.0">
            <hr>
            <label>Backlash X (mm)</label>
            <input type="number" id="bx" value="0.5" step="0.01">
            <label>Backlash Y (mm)</label>
            <input type="number" id="by" value="1.6" step="0.01">
        </div>
    </div>
    
    <label>Line Spacing (mm) - Distance between scan lines</label>
    <input type="number" id="lineSpacing" value="0.6" step="0.1">

    <button id="generateBtn" onclick="generateGCode()">‚ú® Generate Continuous G-Code</button>
    <button id="downloadBtn" onclick="downloadGCode()" style="background: #3498db; display:none; margin-top: 10px;">üíæ Download File</button>

    <textarea id="log" readonly></textarea>
    
    <div class="preview-area">
        <canvas id="canvas"></canvas>
    </div>
</div>

<script>
// =============================================================================
// LOGIC: Backlash Compensator
// =============================================================================
class BacklashCompensator {
    constructor(bx, by) {
        this.bx = bx;
        this.by = by;
        this.threshold = 0.05;
        this.safeFeed = 200;
        
        this.currentX = 0.0;
        this.currentY = 0.0;
        this.offsetX = 0.0;
        this.offsetY = 0.0;
        this.dirX = 0; // 0=None, 1=Pos, -1=Neg
        this.dirY = 0;
    }

    processLines(lines) {
        let newGcode = [];
        const pX = /X([-\d\.]+)/;
        const pY = /Y([-\d\.]+)/;
        const pZ = /Z([-\d\.]+)/;
        const pF = /F([-\d\.]+)/;
        let currentFeed = 500.0;

        for (let line of lines) {
            let originalLine = line.trim();
            if (!originalLine || originalLine.startsWith(';')) {
                newGcode.push(originalLine);
                continue;
            }

            let targetX = this.currentX;
            let targetY = this.currentY;
            let targetZ = null;
            let hasMove = false;

            let mx = originalLine.match(pX);
            if (mx) { targetX = parseFloat(mx[1]); hasMove = true; }

            let my = originalLine.match(pY);
            if (my) { targetY = parseFloat(my[1]); hasMove = true; }

            let mz = originalLine.match(pZ);
            if (mz) { targetZ = parseFloat(mz[1]); }

            let mf = originalLine.match(pF);
            if (mf) { currentFeed = parseFloat(mf[1]); }

            if (!hasMove) {
                newGcode.push(originalLine);
                continue;
            }

            // X Axis
            let dx = targetX - this.currentX;
            if (Math.abs(dx) > this.threshold) {
                let newDirX = dx > 0 ? 1 : -1;
                if (this.dirX !== 0 && newDirX !== this.dirX) {
                    let change = newDirX === 1 ? this.bx : -this.bx;
                    this.offsetX += change;
                    let phyX = this.currentX + this.offsetX;
                    let phyY = this.currentY + this.offsetY;
                    newGcode.push(`; --- FIX X Backlash ---`);
                    newGcode.push(`G0 X${phyX.toFixed(3)} Y${phyY.toFixed(3)} F${this.safeFeed}`);
                    newGcode.push(`G0 F${parseInt(currentFeed)}`);
                }
                this.dirX = newDirX;
            }

            // Y Axis
            let dy = targetY - this.currentY;
            if (Math.abs(dy) > this.threshold) {
                let newDirY = dy > 0 ? 1 : -1;
                if (this.dirY !== 0 && newDirY !== this.dirY) {
                    let change = newDirY === 1 ? this.by : -this.by;
                    this.offsetY += change;
                    let phyX = this.currentX + this.offsetX;
                    let phyY = this.currentY + this.offsetY;
                    newGcode.push(`; --- FIX Y Backlash ---`);
                    newGcode.push(`G0 X${phyX.toFixed(3)} Y${phyY.toFixed(3)} F${this.safeFeed}`);
                    newGcode.push(`G0 F${parseInt(currentFeed)}`);
                }
                this.dirY = newDirY;
            }

            // Reconstruct
            let finalX = targetX + this.offsetX;
            let finalY = targetY + this.offsetY;
            let cmd = originalLine.toUpperCase().includes("G0") ? "G0" : "G1";
            let out = `${cmd} X${finalX.toFixed(3)} Y${finalY.toFixed(3)}`;
            if (targetZ !== null) out += ` Z${targetZ.toFixed(3)}`;
            if (cmd === "G1" && originalLine.toUpperCase().includes("F")) out += ` F${parseInt(currentFeed)}`;
            if (cmd === "G4") out = originalLine;
            newGcode.push(out);

            this.currentX = targetX;
            this.currentY = targetY;
        }
        return newGcode;
    }
}

// =============================================================================
// LOGIC: Continuous Path Generator
// =============================================================================
class ContinuousPathGenerator {
    constructor(params) {
        this.p = params;
        this.gcode = [];
        
        this.zSafe = this.p.zSafe + this.p.zGlobal;
        this.zSafeDip = this.p.zSafeDip + this.p.zGlobal;
        this.zWipeTravel = this.p.zWipe + this.p.zGlobal;
        this.dipLocation = {
            x: this.p.dipX,
            y: this.p.dipY,
            z: this.p.dipZ + this.p.zGlobal
        };

        this.trayEnterRadius = this.p.wipeRadius > 0 ? this.p.wipeRadius * 0.3 : 0;
        this.distSinceLastDip = 0.0;
        this.currentX = this.p.xOffset;
        this.currentY = this.p.yOffset;
    }

    log(msg) {
        const logEl = document.getElementById("log");
        logEl.value += msg + "\n";
        logEl.scrollTop = logEl.scrollHeight;
    }

    removeDrops(trayX, trayY, x, y) {
        let dx = x - trayX;
        let dy = y - trayY;
        let dist = Math.hypot(dx, dy);
        let baseAngle = (dist === 0) ? 0.0 : Math.atan2(dy, dx);
        let variation = (Math.random() * 24 - 12) * (Math.PI / 180);
        let angle = baseAngle + variation;
        let ux = Math.cos(angle), uy = Math.sin(angle);
        let x1 = trayX + ux * this.trayEnterRadius;
        let y1 = trayY + uy * this.trayEnterRadius;
        let x2 = trayX + ux * this.p.wipeRadius;
        let y2 = trayY + uy * this.p.wipeRadius;

        this.gcode.push(`; remove_drops`);
        this.gcode.push(`G0 X${x1.toFixed(3)} Y${y1.toFixed(3)}`);
        this.gcode.push(`G0 Z${this.zWipeTravel.toFixed(3)}`);
        this.gcode.push(`G1 F600`);
        this.gcode.push(`G1 X${x2.toFixed(3)} Y${y2.toFixed(3)}`);
        this.gcode.push(`G0 F${this.p.feedRate}`);
    }

    performDip(targetX, targetY) {
        this.gcode.push("; --- Dip Cycle ---");
        this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)}`);
        this.gcode.push(`G0 X${this.dipLocation.x.toFixed(3)} Y${this.dipLocation.y.toFixed(3)}`);
        this.gcode.push(`G1 Z${this.dipLocation.z.toFixed(3)} F800`);
        if (this.p.dipDuration > 0) this.gcode.push(`G4 P${this.p.dipDuration.toFixed(1)}`);
        this.gcode.push(`G1 Z${this.zWipeTravel.toFixed(3)} F800`);

        let tx = (targetX === null) ? this.dipLocation.x + this.p.wipeRadius : targetX;
        let ty = (targetY === null) ? this.dipLocation.y : targetY;

        if (this.p.removeDrops && this.p.wipeRadius > 0) {
            this.removeDrops(this.dipLocation.x, this.dipLocation.y, tx, ty);
        }

        this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)} F${this.p.feedRate}`);
        this.gcode.push("; --- End Dip ---");
        this.distSinceLastDip = 0.0;
    }

    // Helper: Calculate Z for a specific intensity
    getZ(intensity) {
        // intensity: 0 (black) to 255 (white)
        // depth: maxDepth (negative) to 0
        return -Math.abs(this.p.maxDepth) * (1 - (intensity / 255.0)) + this.p.zGlobal;
    }

    process(imgData, widthPx, heightPx) {
        this.log("Starting Continuous Path generation...");
        this.gcode = [];

        // Init Machine
        this.gcode.push("G90");
        this.gcode.push("G21");
        this.gcode.push(`G0 Z${this.zSafe.toFixed(3)}`);
        this.gcode.push(`G0 F${this.p.feedRate}`);

        if (this.p.dipThreshold > 0) {
            this.log("Initial dip...");
            this.performDip(null, null);
        }
        
        this.gcode.push(`G0 X${this.p.xOffset.toFixed(3)} Y${this.p.yOffset.toFixed(3)} Z${this.zSafe.toFixed(3)}`);

        // --- 1. Detect Continuous Segments ---
        let scaleFactor = this.p.width / widthPx;
        let segments = [];
        const yStepPx = Math.max(1, Math.round(this.p.lineSpacing / scaleFactor)); 

        for (let y = 0; y < heightPx; y += yStepPx) {
            let currentSegment = null;
            let rowYmm = (heightPx - 1 - y) * scaleFactor + this.p.yOffset; // Invert Y

            for (let x = 0; x < widthPx; x++) {
                let intensity = this.getPixelIntensity(imgData, widthPx, x, y);
                
                if (intensity < this.p.dipIntensityThreshold) {
                    // It is dark enough to paint
                    let xMm = x * scaleFactor + this.p.xOffset;
                    let zMm = this.getZ(intensity);

                    if (currentSegment === null) {
                        // Start new segment
                        currentSegment = {
                            y: rowYmm,
                            startX: xMm,
                            endX: xMm,
                            points: [{x: xMm, z: zMm}], // Store intermediate points for interpolation
                            visited: false
                        };
                    } else {
                        // Extend existing segment
                        currentSegment.endX = xMm;
                        currentSegment.points.push({x: xMm, z: zMm});
                    }
                } else {
                    // Light pixel - Break segment
                    if (currentSegment !== null) {
                        segments.push(currentSegment);
                        currentSegment = null;
                    }
                }
            }
            // End of row cleanup
            if (currentSegment !== null) {
                segments.push(currentSegment);
            }
        }

        this.log(`Found ${segments.length} continuous segments.`);

        // --- 2. Optimize Path (Greedy with Reversals) ---
        // We look for the nearest segment START or END to our current position.
        
        let unvisitedCount = segments.length;
        this.currentX = this.p.xOffset;
        this.currentY = this.p.yOffset;

        while (unvisitedCount > 0) {
            let bestSeg = null;
            let bestIdx = -1;
            let bestDist = Infinity;
            let reverse = false; // true if we should paint End->Start

            for (let i = 0; i < segments.length; i++) {
                if (!segments[i].visited) {
                    // Dist to Start
                    let ds = Math.hypot(segments[i].startX - this.currentX, segments[i].y - this.currentY);
                    if (ds < bestDist) {
                        bestDist = ds;
                        bestSeg = segments[i];
                        bestIdx = i;
                        reverse = false;
                    }

                    // Dist to End (Optimization: Can we paint it backwards?)
                    let de = Math.hypot(segments[i].endX - this.currentX, segments[i].y - this.currentY);
                    if (de < bestDist) {
                        bestDist = de;
                        bestSeg = segments[i];
                        bestIdx = i;
                        reverse = true;
                    }
                }
            }

            if (!bestSeg) break;

            // Update Dip Tracker for Travel
            this.distSinceLastDip += bestDist;

            // Move to Start of Segment (High Z)
            let startX = reverse ? bestSeg.endX : bestSeg.startX;
            let startY = bestSeg.y;
            
            this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)}`);
            this.gcode.push(`G0 X${startX.toFixed(3)} Y${startY.toFixed(3)}`);

            // Dip Check before painting
            if (this.p.dipThreshold > 0 && this.distSinceLastDip >= this.p.dipThreshold) {
                this.performDip(startX, startY);
                this.gcode.push(`G0 X${startX.toFixed(3)} Y${startY.toFixed(3)}`);
            }

            // --- PAINT THE SEGMENT ---
            // Get points list in correct order
            let pointsToPaint = reverse ? bestSeg.points.slice().reverse() : bestSeg.points;

            // Plunge to first point Z
            this.gcode.push(`G1 Z${pointsToPaint[0].z.toFixed(3)} F${this.p.feedRate}`);

            // Stream the rest of the points (Variable Z interpolation)
            // We skip every Nth pixel to save G-code size if needed, but 1:1 is smoothest
            for (let p = 1; p < pointsToPaint.length; p++) {
                let pt = pointsToPaint[p];
                this.gcode.push(`G1 X${pt.x.toFixed(3)} Z${pt.z.toFixed(3)}`); // Y implies modal
                
                // Add distance to dip tracker (approximate as X move)
                let moveDist = Math.abs(pt.x - this.currentX); // rough estimate
                this.distSinceLastDip += moveDist;

                // Mid-line dip check (for very long lines)
                if (this.p.dipThreshold > 0 && this.distSinceLastDip >= this.p.dipThreshold) {
                    this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)}`);
                    this.performDip(pt.x, startY);
                    this.gcode.push(`G0 X${pt.x.toFixed(3)} Y${startY.toFixed(3)}`); // Return
                    this.gcode.push(`G1 Z${pt.z.toFixed(3)} F${this.p.feedRate}`); // Plunge back
                }
            }

            // Lift
            this.gcode.push(`G0 Z${this.zSafe.toFixed(3)}`);

            // Mark visited
            segments[bestIdx].visited = true;
            unvisitedCount--;
            this.currentX = reverse ? bestSeg.startX : bestSeg.endX;
            this.currentY = bestSeg.y;
        }

        this.gcode.push("M2");
        this.log("Generation complete.");
        
        // BACKLASH PROCESSING
        if (this.p.bx > 0 || this.p.by > 0) {
            this.log(`Applying Backlash (X:${this.p.bx}, Y:${this.p.by})...`);
            const bl = new BacklashCompensator(this.p.bx, this.p.by);
            this.gcode = bl.processLines(this.gcode);
        }

        return this.gcode.join("\n");
    }

    getPixelIntensity(imgData, width, x, y) {
        let idx = (y * width + x) * 4;
        let r = imgData[idx];
        let g = imgData[idx + 1];
        let b = imgData[idx + 2];
        return (r + g + b) / 3.0;
    }
}

// =============================================================================
// UI HANDLERS
// =============================================================================
let finalGCodeText = "";

document.getElementById('imageInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if(file){
        document.getElementById('fileName').textContent = file.name;
        const reader = new FileReader();
        reader.onload = function(evt) {
            const img = new Image();
            img.onload = function() {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
            }
            img.src = evt.target.result;
        }
        reader.readAsDataURL(file);
    }
});

function generateGCode() {
    const canvas = document.getElementById('canvas');
    if (canvas.width === 0) {
        alert("Please load an image first.");
        return;
    }

    const ctx = canvas.getContext('2d');
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

    const params = {
        width: parseFloat(document.getElementById('width').value),
        maxDepth: parseFloat(document.getElementById('maxDepth').value),
        dipIntensityThreshold: parseFloat(document.getElementById('dipIntensityThreshold').value),
        lineSpacing: parseFloat(document.getElementById('lineSpacing').value),
        feedRate: parseFloat(document.getElementById('feedRate').value),
        xOffset: parseFloat(document.getElementById('xOffset').value),
        yOffset: parseFloat(document.getElementById('yOffset').value),
        dipThreshold: parseFloat(document.getElementById('dipThreshold').value),
        dipX: parseFloat(document.getElementById('dipX').value),
        dipY: parseFloat(document.getElementById('dipY').value),
        dipZ: parseFloat(document.getElementById('dipZ').value),
        dipDuration: parseFloat(document.getElementById('dipDuration').value),
        wipeRadius: parseFloat(document.getElementById('wipeRadius').value),
        removeDrops: document.getElementById('removeDrops').checked,
        zSafe: parseFloat(document.getElementById('zSafe').value),
        zSafeDip: parseFloat(document.getElementById('zSafeDip').value),
        zWipe: parseFloat(document.getElementById('zWipe').value),
        zGlobal: parseFloat(document.getElementById('zGlobal').value),
        bx: parseFloat(document.getElementById('bx').value),
        by: parseFloat(document.getElementById('by').value)
    };

    document.getElementById('log').value = "";
    const generator = new ContinuousPathGenerator(params);
    
    setTimeout(() => {
        finalGCodeText = generator.process(imgData, canvas.width, canvas.height);
        document.getElementById('downloadBtn').style.display = 'block';
    }, 100);
}

function downloadGCode() {
    const blob = new Blob([finalGCodeText], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "continuous_line_paint.gcode";
    a.click();
    window.URL.revokeObjectURL(url);
}
</script>

</body>
</html>