<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Batak Toba G-code Writer</title>
    <style>
        :root {
            --bg: #0b0f19;
            --bg-alt: #0c1222;
            --accent: #ff2dac;
            --accent-soft: rgba(255, 45, 172, 0.2);
            --accent-2: #29e0ff;
            --text: #e5e7eb;
            --muted: #94a3b8;
            --border: #1f2a44;
            --card-bg: #0a0f1a;
            --input-bg: #0f1623;
            --radius-lg: 18px;
            --radius-md: 12px;
            --radius-pill: 999px;
            --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.85);
            --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Inter", sans-serif;
        }

        body {
            font-family: var(--font-sans);
            background: linear-gradient(180deg, var(--bg), var(--bg-alt));
            color: var(--text);
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }

        .page-shell {
            width: 100%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .container {
            background: var(--card-bg);
            padding: 24px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-soft);
            border: 1px solid var(--border);
        }

        h2 {
            margin-top: 0;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .settings-box {
            background: var(--bg);
            padding: 16px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            margin-top: 15px;
        }

        .form-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 12px;
        }

        .form-group {
            margin-bottom: 5px;
            flex: 1 1 140px;
            min-width: 140px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.85rem;
            color: var(--muted);
            font-weight: 600;
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--input-bg);
            color: var(--text);
        }

        button {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: #0b1220;
            border: none;
            padding: 12px 24px;
            border-radius: var(--radius-pill);
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            width: 100%;
            margin-top: 15px;
            transition: transform 0.1s;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px var(--accent-soft);
        }


        #status {
            margin-top: 15px;
            padding: 10px;
            background: #000;
            color: #00ff66;
            font-family: monospace;
            font-size: 12px;
            border-radius: 4px;
            display: none;
        }

        .previews-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .preview-item {
            background: white;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--border);
            text-align: center;
        }

        .preview-item h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        canvas {
            border: 1px solid #ccc;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            image-rendering: pixelated;
        }

        textarea {
            width: 100%;
            height: 200px;
            margin-top: 20px;
            background: #111;
            color: #eee;
            font-family: monospace;
            padding: 10px;
            border: 1px solid var(--border);
        }

        @font-face {
            font-family: 'NotoSansBatak';
            src: url('data:font/ttf;base64,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AHQAdABwADoALwAvAHcAdwB3AC4AZwBvAG8AZwBsAGUALgBjAG8AbQAvAGcAZQB0AC8AbgBvAHQAbwAvAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBtAG8AbgBvAHQAeQBwAGUALgBjAG8AbQAvAHMAdAB1AGQAaQBvAFQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAaQBzACAAbABpAGMAZQBuAHMAZQBkACAAdQBuAGQAZQByACAAdABoAGUAIABTAEkATAAgAE8AcABlAG4AIABGAG8AbgB0ACAATABpAGMAZQBuAHMAZQAsACAAVgBlAHIAcwBpAG8AbgAgADEALgAxAC4AIABUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAG8AbgAgAGEAbgAgACIAQQBTACAASQBTACIAIABCAEEAUwBJAFMALAAgAFcASQBUAEgATwBVAFQAIABXAEEAUgBSAEEATgBUAEkARQBTACAATwBSACAAQwBPAE4ARABJAFQASQBPAE4AUwAgAE8ARgAgAEEATgBZACAASwBJAE4ARAAsACAAZQBpAHQAaABlAHIAIABlAHgAcAByAGUAcwBzACAAbwByACAAaQBtAHAAbABpAGUAZAAuACAAUwBlAGUAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACAAZgBvAHIAIAB0AGgAZQAgAHMAcABlAGMAaQBmAGkAYwAgAGwAYQBuAGcAdQBhAGcAZQAsACAAcABlAHIAbQBpAHMAcwBpAG8AbgBzACAAYQBuAGQAIABsAGkAbQBpAHQAYQB0AGkAbwBuAHMAIABnAG8AdgBlAHIAbgBpAG4AZwAgAHkAbwB1AHIAIAB1AHMAZQAgAG8AZgAgAHQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlAC4AaAB0AHQAcAA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAAAAAgAAAAAAAP+cADIAAAAAAAAAAAAAAAAAAAAAAAAAAABbAAABAgEDAAMBBAEFAQYBBwEIAQkBCgELAQwBDQEOAQ8BEAERARIBEwEUARUBFgEXARgBGQEaARsBHAEdAR4BHwEgASEBIgEjASQBJQEmAScBKAEpASoBKwEsAS0BLgEvATABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwFQAVEBUgFTAVQBVQFWAVcBWAFZAVoETlVMTAJDUgduYnNwYWNlDnplcm93aWR0aHNwYWNlBFpXTkoDWldKDGRvdHRlZENpcmNsZQdhLWJhdGFrDWFfdVNpZ24tYmF0YWsLYVNpbWEtYmF0YWsIaGEtYmF0YWsOaGFfdVNpZ24tYmF0YWsMaGFTaW1hLWJhdGFrDmhhTWFuZGFpLWJhdGFrFGhhTWFuZGFpX3VTaWduLWJhdGFrCGJhLWJhdGFrDmJhX3VTaWduLWJhdGFrDGthcm9CYS1iYXRhaxJrYXJvQmFfdVNpZ24tYmF0YWsIcGEtYmF0YWsMcGFTaW1hLWJhdGFrCG5hLWJhdGFrDm5hX3VTaWduLWJhdGFrDm5hTWFuZGFpLWJhdGFrFG5hTWFuZGFpX3VTaWduLWJhdGFrCHdhLWJhdGFrDndhX3VTaWduLWJhdGFrDHdhU2ltYS1iYXRhaxJ3YVNpbWFfdVNpZ24tYmF0YWsOcGFrcGFrV2EtYmF0YWsIZ2EtYmF0YWsOZ2FfdVNpZ24tYmF0YWsMZ2FTaW1hLWJhdGFrCGphLWJhdGFrDmphX3VTaWduLWJhdGFrDGphLWJhdGFrLmJ0eBJqYV91U2lnbi1iYXRhay5idHgIZGEtYmF0YWsOZGFfdVNpZ24tYmF0YWsIcmEtYmF0YWsOcmFfdVNpZ24tYmF0YWsMcmFTaW1hLWJhdGFrCG1hLWJhdGFrDm1hX3VTaWduLWJhdGFrDG1hU2ltYS1iYXRhaxJtYVNpbWFfdVNpZ24tYmF0YWsNdGFTb3V0aC1iYXRhaxN0YVNvdXRoX3VTaWduLWJhdGFrDXRhTm9ydGgtYmF0YWsTdGFOb3J0aF91U2lnbi1iYXRhawhzYS1iYXRhawxzYVNpbWEtYmF0YWsOc2FNYW5kYWktYmF0YWsUc2FNYW5kYWlfdVNpZ24tYmF0YWsIeWEtYmF0YWsMeWFTaW1hLWJhdGFrCW5nYS1iYXRhaw9uZ2FfdVNpZ24t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AAAAAQABAAEAAAABAAAAAQAAAAEAAAABAAEAAAABAAEAAAAAAAAAAQAAAAEAAAABAAEAAAABAAAAAQAAAAEAAAABAAEAAQAAAAEAAQABAAAAAQAAAAEAAQAAAAEAAQABAAAAAAAAAAsACgAJAAgABwAGAAUABAAAAAAAAwAAAAAAAgACAAAAAQAEAAMAAgABAAIAAAAAAAIACQABAAQAAwACAAEAAgAAAAAAAgAIAAEABAADAAIAAQACAAAAAAACAAcAAQAEAAMAAgABAAIAAAAAAAIABgABAAQAAwACAAEAAgAAAAAAAgAFAAEABAADAAIAAQACAAAAAAACAAQAAQAEAAMAAgABAAIAAAAAAAIAAwABAAQAAwACAAEAAgAAAAAAAgACAAEABAADAAIAAQACAAAAAAACAAEAAQAAAAEACAABAAYAAgABAAEAIwAGABAAAQAKAAEAAwABABIAAQGeAAAAAQAAAA0AAQABABUAAQAQAAEACgABAAEBfAABAAQAEAABAAoAAQABAQIAFQAwADoARABOAFgAYgBsAHYAgACKAJQAngCoALIAvADGANAA2gDkAO4A+AABAAQACgACAE4AAQAEAA0AAgBOAAEABAAQAAIATgABAAQAEgACAE4AAQAEABQAAgBOAAEABAAYAAIATgABAAQAGgACAE4AAQAEABwAAgBOAAEABAAhAAIATgABAAQAJAACAE4AAQAEACYAAgBOAAEABAAoAAIATgABAAQAKgACAE4AAQAEAC0AAgBOAAEABAAvAAIATgABAAQAMQACAE4AAQAEADMAAgBOAAEABAA3AAIATgABAAQAOwACAE4AAQAEAD0AAgBOAAEABABAAAIATgABABUACQAMAA8AEQATABcAGQAbACAAIwAlACcAKQAsAC4AMAAyADYAOgA8AD8ABgAQAAEACgABAAMAAQASAAEAMgAAAAEAAAAQAAEABgALAA4AHQAiACsALgABABAAAQAKAAEAAQAGAAIAAQABAE4AAAABAAAAAA==') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        .font-load-tester {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            font-family: 'NotoSansBatak';
            white-space: nowrap;
        }
    </style>
</head>

<body>
    <!-- Hidden element to force font loading -->
    <div class="font-load-tester">ᯂᯬᯒᯘ᯲</div>

    <div class="page-shell">
        <div class="container">
            <h2>ᯂᯬᯒᯘ᯲ Batak Toba Writer</h2>
            <p style="color: var(--muted); font-size: 0.9rem;">Generate single-stroke G-code for Batak script with
                plotter optimizations.</p>

            <div id="fontNotice"
                style="background: rgba(255,165,0,0.1); border: 1px solid orange; padding: 10px; border-radius: 8px; margin-bottom: 15px; display: none; color: orange; font-size: 0.85rem;">
                <b>Font Loading Notice:</b> If you see squares below, the font didn't load. Try refreshing or check if
                'NotoSansBatak-Regular.ttf' is in the same folder.
                <div style="font-family: 'NotoSansBatak'; font-size: 24px; margin-top: 5px;">ᯂᯬᯒᯘ᯲ (Font Preview)</div>
            </div>

            <div class="settings-box">
                <div class="form-row">
                    <div class="form-group" style="flex: 2;">
                        <label for="inputText">Text (Latin or Batak):</label>
                        <input type="text" id="inputText" value="horas" placeholder="Type here...">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="width">Width (mm):</label>
                        <input type="number" id="width" value="120" step="1">
                    </div>
                    <div class="form-group">
                        <label for="ox">Offset X (mm):</label>
                        <input type="number" id="ox" value="10" step="1">
                    </div>
                    <div class="form-group">
                        <label for="oy">Offset Y (mm):</label>
                        <input type="number" id="oy" value="30" step="1">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="feed">Feed Rate (mm/min):</label>
                        <input type="number" id="feed" value="1600">
                    </div>
                    <div class="form-group">
                        <label for="pickupDist">Pickup Dist (mm):</label>
                        <input type="number" id="pickupDist" value="40">
                    </div>
                    <div class="form-group">
                        <label for="minLen">Min Stroke (mm):</label>
                        <input type="number" id="minLen" value="3" step="1">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="bx">Backlash X (mm):</label>
                        <input type="number" id="bx" value="2.0" step="0.1">
                    </div>
                    <div class="form-group">
                        <label for="by">Backlash Y (mm):</label>
                        <input type="number" id="by" value="2.0" step="0.1">
                    </div>
                    <div class="form-group" style="display: flex; align-items: flex-end; padding-bottom: 5px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="optimize" checked> Optimize Path
                        </label>
                    </div>
                </div>
            </div>

            <button onclick="generate()">Generate G-code</button>

            <div id="status"></div>

            <div class="previews-container">
                <div class="preview-item">
                    <h4>Skeleton Preview</h4>
                    <canvas id="canvas"></canvas>
                </div>
                <div class="preview-item">
                    <h4>G-code Preview (Plotter View)</h4>
                    <canvas id="gcodeCanvas"></canvas>
                </div>
            </div>

            <textarea id="gcodeOutput" readonly placeholder="G-code will appear here..."></textarea>
            <button id="downloadBtn" style="background: #22c55e; color: white; display: none;"
                onclick="downloadGcode()">Download .gcode</button>
        </div>
    </div>

    <script>
        // --- Transliteration ---
        function transliterateToba(text) {
            const consonants = {
                'h': '\u1BC2', 'k': '\u1BC2',
                'g': '\u1BCE', 'n': '\u1BC9', 'm': '\u1BD4',
                'b': '\u1BC5', 't': '\u1BD6', 'd': '\u1BD1', 'p': '\u1BC7',
                'w': '\u1BCB', 's': '\u1BD8', 'y': '\u1BDB', 'l': '\u1BDE',
                'r': '\u1BD2', 'j': '\u1BD0', 'c': '\u1BD0',
                'f': '\u1BC7', 'v': '\u1BC5',
                'a': '\u1BC0', 'i': '\u1BE4', 'u': '\u1BE5'
            };
            const vowels = {
                'i': '\u1BEA', 'u': '\u1BEE', 'e': '\u1BE7', 'o': '\u1BEC',
            };
            const pangolat = '\u1BF2';
            const amborolong = '\u1BF0';

            let t = text.toLowerCase().trim()
                .replace(/ng/g, 'ŋ');

            let res = "";
            let i = 0;
            while (i < t.length) {
                let char = t[i];
                if (char === 'ŋ') {
                    res += amborolong;
                    i++; continue;
                }

                if (consonants[char]) {
                    res += consonants[char];
                    if (i + 1 < t.length) {
                        let next = t[i + 1];
                        if (vowels[next]) {
                            res += vowels[next];
                            i += 2; continue;
                        } else if (next === 'a') {
                            i += 2; continue;
                        } else {
                            // Closed syllable
                            if (!['a', 'i', 'u'].includes(char)) res += pangolat;
                        }
                    } else {
                        // End of word
                        if (!['a', 'i', 'u'].includes(char)) res += pangolat;
                    }
                } else if (char === 'a') {
                    // Start of word 'a' is consonants['a']
                    res += consonants['a'];
                } else if (vowels[char]) {
                    // Start of word vowel
                    let base = char === 'i' ? '\u1BE4' : (char === 'u' ? '\u1BE5' : '\u1BC0');
                    res += base;
                    if (char === 'e' || char === 'o') res += vowels[char];
                }
                i++;
            }
            return res;
        }

        // --- Thinning Algorithm (Zhang-Suen) ---
        function thinning(pixels, w, h) {
            let iter = 0;
            let stop = false;
            while (!stop) {
                stop = true;
                let toRemove = [];
                for (let pass = 0; pass < 2; pass++) {
                    let passToRemove = [];
                    for (let y = 1; y < h - 1; y++) {
                        for (let x = 1; x < w - 1; x++) {
                            let idx = y * w + x;
                            if (pixels[idx] === 0) continue;

                            let p2 = pixels[(y - 1) * w + x];
                            let p3 = pixels[(y - 1) * w + x + 1];
                            let p4 = pixels[y * w + x + 1];
                            let p5 = pixels[(y + 1) * w + x + 1];
                            let p6 = pixels[(y + 1) * w + x];
                            let p7 = pixels[(y + 1) * w + x - 1];
                            let p8 = pixels[y * w + x - 1];
                            let p9 = pixels[(y - 1) * w + x - 1];

                            let b = p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9;
                            let a = (p2 == 0 && p3 == 1) + (p3 == 0 && p4 == 1) + (p4 == 0 && p5 == 1) + (p5 == 0 && p6 == 1) +
                                (p6 == 0 && p7 == 1) + (p7 == 0 && p8 == 1) + (p8 == 0 && p9 == 1) + (p9 == 0 && p2 == 1);

                            let m1 = (pass === 0) ? (p2 * p4 * p6) : (p2 * p4 * p8);
                            let m2 = (pass === 0) ? (p4 * p6 * p8) : (p2 * p6 * p8);

                            if (a === 1 && (b >= 2 && b <= 6) && m1 === 0 && m2 === 0) {
                                passToRemove.push(idx);
                                stop = false;
                            }
                        }
                    }
                    for (let idx of passToRemove) pixels[idx] = 0;
                }
            }

            // Morphological Clean: Aggressively eliminate jitter
            for (let iter = 0; iter < 6; iter++) {
                for (let y = 1; y < h - 1; y++) {
                    for (let x = 1; x < w - 1; x++) {
                        let idx = y * w + x;
                        if (!pixels[idx]) continue;

                        let n = 0;
                        for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            if (pixels[(y + dy) * w + (x + dx)]) n++;
                        }

                        // Kill pixels with > 2 neighbors if they form clusters
                        if (n > 2) {
                            if (pixels[idx + 1] && pixels[idx + w] && pixels[idx + w + 1]) pixels[idx] = 0;
                            if (pixels[idx - 1] && pixels[idx + w] && pixels[idx + w - 1]) pixels[idx] = 0;
                            if (pixels[idx - 1] && pixels[idx - w] && pixels[idx - w - 1]) pixels[idx] = 0;
                            if (pixels[idx + 1] && pixels[idx - w] && pixels[idx - w + 1]) pixels[idx] = 0;
                        }

                        // Remove staircase steps
                        if (pixels[idx - 1] && pixels[idx - w] && !pixels[idx - w - 1]) pixels[idx] = 0;
                        if (pixels[idx + 1] && pixels[idx + w] && !pixels[idx + w + 1]) pixels[idx] = 0;
                    }
                }
            }
        }

        // --- Path Resampling (Avoid point clusters) ---
        function resamplePath(points, dist = 1.0) {
            if (points.length < 2) return points;
            let result = [points[0]];
            for (let i = 0; i < points.length - 1; i++) {
                let p1 = points[i], p2 = points[i + 1];
                let d = Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2);
                if (d > dist) {
                    let steps = Math.floor(d / dist);
                    for (let j = 1; j <= steps; j++) {
                        let t = j / (steps + 1);
                        result.push([p1[0] + (p2[0] - p1[0]) * t, p1[1] + (p2[1] - p1[1]) * t]);
                    }
                }
                result.push(p2);
            }
            return result;
        }

        // --- Path Smoothing (Gaussian) ---
        function smoothPath(points, iterations = 20) {
            if (points.length < 3) return points;
            let current = points;
            for (let iter = 0; iter < iterations; iter++) {
                let next = [current[0]];
                for (let i = 1; i < current.length - 1; i++) {
                    next.push([
                        (current[i - 1][0] * 0.2 + current[i][0] * 0.6 + current[i + 1][0] * 0.2),
                        (current[i - 1][1] * 0.2 + current[i][1] * 0.6 + current[i + 1][1] * 0.2)
                    ]);
                }
                next.push(current[current.length - 1]);
                current = next;
            }
            return current;
        }

        // --- Skeleton Pruning (Remove 'hairs') ---
        function pruneSkeleton(pixels, w, h, iterations = 5) {
            for (let i = 0; i < iterations; i++) {
                let toRemove = [];
                for (let y = 1; y < h - 1; y++) {
                    for (let x = 1; x < w - 1; x++) {
                        let idx = y * w + x;
                        if (pixels[idx] === 0) continue;

                        let neighbors = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                if (pixels[(y + dy) * w + (x + dx)]) neighbors++;
                            }
                        }
                        if (neighbors === 1) toRemove.push(idx); // Endpoint
                    }
                }
                if (toRemove.length === 0) break;
                for (let idx of toRemove) pixels[idx] = 0;
            }
        }

        // --- Path Simplification (RDP + Collinear Merge) ---
        function mergeCollinearSegments(points, thres = 0.2) {
            if (points.length < 3) return points;
            let result = [points[0]];
            for (let i = 1; i < points.length - 1; i++) {
                let p1 = result[result.length - 1];
                let p2 = points[i];
                let p3 = points[i + 1];
                let area = Math.abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]));
                let dist = Math.sqrt((p1[0] - p3[0]) ** 2 + (p1[1] - p3[1]) ** 2);
                if (area / (dist || 1) > thres) result.push(p2);
            }
            result.push(points[points.length - 1]);
            return result;
        }

        function simplifyPath(points, epsilon) {
            if (points.length <= 2) return points;

            let dmax = 0;
            let index = 0;
            let end = points.length - 1;

            for (let i = 1; i < end; i++) {
                let d = distToSegment(points[i], points[0], points[end]);
                if (d > dmax) {
                    index = i;
                    dmax = d;
                }
            }

            let simplified;
            if (dmax > epsilon) {
                let recResults1 = simplifyPath(points.slice(0, index + 1), epsilon);
                let recResults2 = simplifyPath(points.slice(index), epsilon);
                simplified = recResults1.slice(0, recResults1.length - 1).concat(recResults2);
            } else {
                simplified = [points[0], points[end]];
            }
            return mergeCollinearSegments(simplified);
        }

        function distToSegment(p, v, w) {
            let l2 = (v[0] - w[0]) ** 2 + (v[1] - w[1]) ** 2;
            if (l2 == 0) return Math.sqrt((p[0] - v[0]) ** 2 + (p[1] - v[1]) ** 2);
            let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;
            t = Math.max(0, Math.min(1, t));
            let dx = p[0] - (v[0] + t * (w[0] - v[0]));
            let dy = p[1] - (v[1] + t * (w[1] - v[1]));
            return Math.sqrt(dx * dx + dy * dy);
        }

        // --- Path Generation ---
        function getPaths(pixels, w, h, optimize) {
            let edges = [];
            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    if (pixels[y * w + x] === 0) continue;
                    let neighbors = [
                        [x + 1, y], [x + 1, y + 1], [x, y + 1], [x - 1, y + 1],
                        [x - 1, y], [x - 1, y - 1], [x, y - 1], [x + 1, y - 1]
                    ];
                    for (let [nx, ny] of neighbors) {
                        if (pixels[ny * w + nx]) {
                            let u = y * w + x;
                            let v = ny * w + nx;
                            if (u < v) edges.push([u, v]);
                        }
                    }
                }
            }

            let adj = {};
            for (let [u, v] of edges) {
                if (!adj[u]) adj[u] = new Set();
                if (!adj[v]) adj[v] = new Set();
                adj[u].add(v);
                adj[v].add(u);
            }

            let paths = [];
            let edgeSet = new Set(edges.map(e => e[0] + '-' + e[1]));

            while (edgeSet.size > 0) {
                let startNode = -1;
                let minDegree = 9;

                // Find endpoint
                let candidates = new Set();
                edgeSet.forEach(e => {
                    let [u, v] = e.split('-').map(Number);
                    candidates.add(u); candidates.add(v);
                });

                for (let node of candidates) {
                    let degree = 0;
                    adj[node].forEach(neighbor => {
                        if (edgeSet.has(Math.min(node, neighbor) + '-' + Math.max(node, neighbor))) degree++;
                    });
                    if (degree > 0 && degree < minDegree) {
                        minDegree = degree;
                        startNode = node;
                        if (degree === 1) break;
                    }
                }
                if (startNode === -1) break;

                let path = [startNode];
                let curr = startNode;
                while (true) {
                    let next = -1;
                    let neighbors = Array.from(adj[curr] || []);

                    // Prefer continuing in same direction
                    if (path.length >= 2) {
                        let prev = path[path.length - 2];
                        let dx = (curr % w) - (prev % w);
                        let dy = Math.floor(curr / w) - Math.floor(prev / w);

                        let bestDot = -2;
                        for (let n of neighbors) {
                            let key = Math.min(curr, n) + '-' + Math.max(curr, n);
                            if (edgeSet.has(key)) {
                                let ndx = (n % w) - (curr % w);
                                let ndy = Math.floor(n / w) - Math.floor(curr / w);
                                let dot = dx * ndx + dy * ndy;
                                if (dot > bestDot) {
                                    bestDot = dot;
                                    next = n;
                                }
                            }
                        }
                    }

                    if (next === -1) {
                        for (let n of neighbors) {
                            let key = Math.min(curr, n) + '-' + Math.max(curr, n);
                            if (edgeSet.has(key)) {
                                next = n;
                                break;
                            }
                        }
                    }

                    if (next === -1) break;
                    let key = Math.min(curr, next) + '-' + Math.max(curr, next);
                    edgeSet.delete(key);
                    path.push(next);
                    curr = next;
                }

                if (path.length > 2) {
                    let coords = path.map(idx => [idx % w, Math.floor(idx / w)]);
                    let resampled = resamplePath(coords, 0.8);
                    let smoothed = smoothPath(resampled, 12);

                    // Kill terminal hooks
                    if (smoothed.length > 5) smoothed = smoothed.slice(1, -1);

                    let simplified = simplifyPath(smoothed, 1.2);
                    if (simplified.length > 1) paths.push(simplified);
                }
            }

            // JOINING LOGIC: Aggressively connect paths to minimize jumps
            let changed = true;
            while (changed) {
                changed = false;
                for (let i = 0; i < paths.length; i++) {
                    for (let j = i + 1; j < paths.length; j++) {
                        let p1 = paths[i], p2 = paths[j];
                        let t1 = p1[p1.length - 1], h1 = p1[0];
                        let t2 = p2[p2.length - 1], h2 = p2[0];

                        const d2 = (a, b) => (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2;
                        const limitSq = 900; // 30 pixels joining at high-res

                        if (d2(t1, h2) < limitSq) {
                            paths[i] = p1.concat(p2.slice(1)); paths.splice(j, 1); changed = true; break;
                        } else if (d2(t1, t2) < limitSq) {
                            paths[i] = p1.concat(p2.slice(0, -1).reverse()); paths.splice(j, 1); changed = true; break;
                        } else if (d2(h1, h2) < limitSq) {
                            paths[i] = p1.reverse().concat(p2.slice(1)); paths.splice(j, 1); changed = true; break;
                        } else if (d2(h1, t2) < limitSq) {
                            paths[i] = p2.concat(p1.slice(1)); paths.splice(j, 1); changed = true; break;
                        }
                    }
                    if (changed) break;
                }
            }

            // Left-to-right sorting (ensure characters are drawn in order)
            paths.sort((a, b) => {
                let minA = Math.min(a[0][0], a[a.length - 1][0]);
                let minB = Math.min(b[0][0], b[b.length - 1][0]);
                return minA - minB;
            });
            return paths;
        }

        // --- Backlash Fixer ---
        class BacklashFixer {
            constructor(bx, by) {
                this.bx = bx; this.by = by;
                this.cx = 0; this.cy = 0;
                this.ox = 0; this.oy = 0;
                this.dx = 1; this.dy = 1; // Assume initial direction for stability
                this.threshold = 1.0;
            }
            process(targetX, targetY, isG0, feed) {
                let cmds = [];
                let dx = targetX - this.cx;
                let dy = targetY - this.cy;

                // Sensitive threshold to capture every direction flip
                const moveThres = 0.1;

                if (Math.abs(dx) > moveThres) {
                    let ndx = dx > 0 ? 1 : -1;
                    if (this.dx !== 0 && ndx !== this.dx) {
                        this.ox += (ndx === 1 ? this.bx : -this.bx);
                    }
                    this.dx = ndx;
                }
                if (Math.abs(dy) > moveThres) {
                    let ndy = dy > 0 ? 1 : -1;
                    if (this.dy !== 0 && ndy !== this.dy) {
                        this.oy += (ndy === 1 ? this.by : -this.by);
                    }
                    this.dy = ndy;
                }

                let fx = targetX + this.ox;
                let fy = targetY + this.oy;
                let cmd = isG0 ? "G0" : "G1";
                let line = `${cmd} X${fx.toFixed(3)} Y${fy.toFixed(3)}`;
                if (!isG0) line += ` F${feed}`;
                cmds.push(line);
                this.cx = targetX; this.cy = targetY;
                return cmds;
            }
        }

        // --- Main Runner ---
        async function generate() {
            const status = document.getElementById('status');
            const notice = document.getElementById('fontNotice');
            status.style.display = 'block';
            status.innerHTML = "Initializing...";

            // Ensure font is ready
            try {
                if (document.fonts && document.fonts.load) {
                    await document.fonts.load('800px NotoSansBatak');
                }
                await document.fonts.ready;
                status.innerHTML += "<br>High-res fonts active.";
                notice.style.display = 'none'; // Hide notice on success
            } catch (e) {
                console.warn("Font loading wait failed", e);
                notice.style.display = 'block';
            }

            const textStr = document.getElementById('inputText').value;
            const targetW = parseFloat(document.getElementById('width').value);
            const offX = parseFloat(document.getElementById('ox').value);
            const offY = parseFloat(document.getElementById('oy').value);
            const feed = parseInt(document.getElementById('feed').value);
            const pickupThreshold = parseFloat(document.getElementById('pickupDist').value);
            const minLen = parseFloat(document.getElementById('minLen').value);
            const bxVal = parseFloat(document.getElementById('bx').value);
            const byVal = parseFloat(document.getElementById('by').value);
            const optimize = document.getElementById('optimize').checked;

            if (!textStr) {
                status.innerHTML = "<span class='error'>Please enter some text.</span>";
                return;
            }

            let batakText = textStr;
            if (/^[a-zA-Z\s]+$/.test(textStr)) {
                batakText = transliterateToba(textStr);
                status.innerHTML += `<br>Transliterated: <b>${batakText}</b>`;
            }

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            // High-res render for skeletonization - Using BOLD for stability
            const fontSize = 900;
            ctx.font = `bold ${fontSize}px NotoSansBatak`;
            const metrics = ctx.measureText(batakText);

            const w = Math.ceil(metrics.width) + 400;
            const h = fontSize + 400;
            canvas.width = w; canvas.height = h;

            // Reset and Draw
            ctx.fillStyle = "white"; ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = "black";
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            ctx.font = `bold ${fontSize}px NotoSansBatak`;
            ctx.fillText(batakText, w / 2, h / 2);

            const imgData = ctx.getImageData(0, 0, w, h);
            const pixels = new Int8Array(w * h);
            let blackCount = 0;
            for (let i = 0; i < imgData.data.length; i += 4) {
                if (imgData.data[i] < 128) {
                    pixels[i / 4] = 1;
                    blackCount++;
                } else {
                    pixels[i / 4] = 0;
                }
            }

            if (blackCount === 0) {
                status.innerHTML += "<br><span class='error'>Error: Nothing rendered. Check if font supports these characters.</span>";
                return;
            }

            // Despeckle (remove isolated pixels)
            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    let idx = y * w + x;
                    if (pixels[idx] === 1) {
                        let n = pixels[(y - 1) * w + x] + pixels[(y + 1) * w + x] + pixels[y * w + x - 1] + pixels[y * w + x + 1];
                        if (n === 0) pixels[idx] = 0;
                    }
                }
            }

            // Run thinning and ultra-aggressive pruning
            thinning(pixels, w, h);
            pruneSkeleton(pixels, w, h, 20); // Deep pruning of hairs/spurs

            // Re-draw skeleton for preview
            ctx.fillStyle = "white"; ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = "black";
            let skeletonCount = 0;
            for (let i = 0; i < pixels.length; i++) {
                if (pixels[i]) {
                    let x = i % w, y = Math.floor(i / w);
                    ctx.fillRect(x - 1, y - 1, 3, 3); // Thicker line (3x3 block)
                    skeletonCount++;
                }
            }
            status.innerHTML += `<br>Skeleton generated (${skeletonCount} points).`;

            status.innerHTML += "<br>Extracting paths...";
            let paths = getPaths(pixels, w, h, optimize);

            if (paths.length === 0) {
                status.innerHTML += "<br><span class='error'>Error: No paths extracted from skeleton.</span>";
                return;
            }

            // Find bounds for calculation
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (let p of paths) {
                for (let [x, y] of p) {
                    if (x < minX) minX = x; if (x > maxX) maxX = x;
                    if (y < minY) minY = y; if (y > maxY) maxY = y;
                }
            }

            const contentW = (maxX - minX) || 1;
            const contentH = (maxY - minY) || 1;
            const scale = targetW / contentW;

            // Filter short strokes
            let filtered = [];
            for (let p of paths) {
                let len = 0;
                for (let i = 0; i < p.length - 1; i++) {
                    len += Math.sqrt((p[i][0] - p[i + 1][0]) ** 2 + (p[i][1] - p[i + 1][1]) ** 2);
                }
                if (len * scale >= minLen) filtered.push(p);
            }

            status.innerHTML += `<br>Final path count: ${filtered.length} strokes.`;

            // G-code Generation
            let gcode = [
                "%",
                `(Batak script: ${textStr})`,
                `(Batak Unicode: ${batakText})`,
                `(Width: ${targetW}mm, Scale: ${scale.toFixed(4)})`,
                "G21 G90"
            ];

            const COLOR1_PICKUP = `
; Colour 1 pickup
G1 Z10 F1000;
G0 X41 Y5 F1200;
G1 Z0 F1000;
G1 X40.102 Y7.295 Z0 S800 F1200;
G1 X40.026 Y7.642 Z0 F1200;
G1 X40 Y8 Z0 F1200;
G1 X40.026 Y8.358 Z0 F1200;
G1 X40.102 Y8.705 Z0 F1200;
G1 X42.617 Y11.078 Z0 F1200;
G1 X45 Y11.5 Z0 F1200;
G1 X50 Y8 Z0 F1200;
G1 X45 Y4.5 Z0 F1200;
G1 X41.82 Y5.299 Z0 F1200;
G1 Z7 F800;
G1 X34 Y8 Z1 F1200;
G1 X24 Y18 Z8 F500;
G1 F1200;
`;
            gcode.push(COLOR1_PICKUP.trim());
            gcode.push("G0 Z5");

            let accumDist = 0;
            let fixer = new BacklashFixer(bxVal, byVal);

            for (let path of filtered) {
                if (accumDist >= pickupThreshold) {
                    gcode.push("; --- Periodic Color Pickup ---");
                    gcode.push(COLOR1_PICKUP.trim());
                    gcode.push("G0 Z5");
                    accumDist = 0;
                }

                let first = true;
                let lastX, lastY;
                for (let [px, py] of path) {
                    let tx = (px - minX) * scale + offX;
                    let ty = (contentH - (py - minY)) * scale + offY;

                    if (first) {
                        fixer.process(tx, ty, true, feed).forEach(l => gcode.push(l));
                        gcode.push(`G1 Z0 F${feed}`);
                        first = false;
                    } else {
                        fixer.process(tx, ty, false, feed).forEach(l => gcode.push(l));
                        accumDist += Math.sqrt((tx - lastX) ** 2 + (ty - lastY) ** 2);
                    }
                    lastX = tx; lastY = ty;
                }
                gcode.push("G0 Z5");
            }

            gcode.push("G0 X10 Y130");
            gcode.push("M30", "%");

            document.getElementById('gcodeOutput').value = gcode.join('\n');
            document.getElementById('downloadBtn').style.display = 'block';
            status.innerHTML += "<br><b>Done!</b> G-code generated.";

            renderGcodePreview(gcode.join('\n'));
        }

        function renderGcodePreview(gcodeText) {
            const canvas = document.getElementById('gcodeCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size for 150x140 plotter view
            canvas.width = 600;
            canvas.height = 580;

            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const lines = gcodeText.split('\n');
            let cx = null, cy = null, cz = 10;
            let paths = [];
            let currentPath = [];

            // Skip comments and non-move lines for initial position
            for (let line of lines) {
                line = line.split(';')[0].trim();
                const xMatch = line.match(/X(-?\d+\.?\d*)/);
                const yMatch = line.match(/Y(-?\d+\.?\d*)/);
                if (xMatch && yMatch && (line.startsWith('G0') || line.startsWith('G1'))) {
                    cx = parseFloat(xMatch[1]);
                    cy = parseFloat(yMatch[1]);
                    break;
                }
            }
            if (cx === null) { cx = 0; cy = 0; }

            const margin = 30;
            const plotW = 150;
            const plotH = 140;
            const scale = (canvas.width - 2 * margin) / plotW;

            function toPX(x, y) {
                return {
                    x: margin + x * scale,
                    y: canvas.height - margin - y * scale
                };
            }

            // Draw Bed Boundary (150x140mm)
            ctx.strokeStyle = "#ccc";
            ctx.setLineDash([5, 5]);
            const b1 = toPX(0, 0), b2 = toPX(150, 140);
            ctx.strokeRect(b1.x, b2.y, (150 * scale), (140 * scale));
            ctx.setLineDash([]);
            ctx.fillStyle = "#999";
            ctx.font = "12px sans-serif";
            ctx.fillText("150mm x 140mm Plotter Bed", b1.x, b2.y - 10);

            for (let line of lines) {
                line = line.split(';')[0].trim();
                const xMatch = line.match(/X(-?\d+\.?\d*)/);
                const yMatch = line.match(/Y(-?\d+\.?\d*)/);
                const zMatch = line.match(/Z(-?\d+\.?\d*)/);

                let nx = xMatch ? parseFloat(xMatch[1]) : cx;
                let ny = yMatch ? parseFloat(yMatch[1]) : cy;
                let nz = zMatch ? parseFloat(zMatch[1]) : cz;

                if (line.startsWith('G0') || line.startsWith('G1')) {
                    if (nz <= 0.5) { // Drawing
                        if (currentPath.length === 0) {
                            currentPath.push([cx, cy]);
                        }
                        currentPath.push([nx, ny]);
                    } else { // Travel
                        if (currentPath.length > 0) {
                            paths.push(currentPath);
                            currentPath = [];
                        }
                        // Draw travel move in very faint gray
                        const p1 = toPX(cx, cy);
                        const p2 = toPX(nx, ny);
                        ctx.strokeStyle = "#f3f4f6";
                        ctx.lineWidth = 1.0;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }
                cx = nx; cy = ny; cz = nz;
            }
            if (currentPath.length > 0) paths.push(currentPath);

            // Draw Drawing paths
            ctx.lineWidth = 3.0;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = "#ff2dac"; // Neon pink 

            for (let p of paths) {
                ctx.beginPath();
                const p0 = toPX(p[0][0], p[0][1]);
                ctx.moveTo(p0.x, p0.y);
                for (let i = 1; i < p.length; i++) {
                    const pi = toPX(p[i][0], p[i][1]);
                    ctx.lineTo(pi.x, pi.y);
                }
                ctx.stroke();
            }
        }

        function downloadGcode() {
            const text = document.getElementById('gcodeOutput').value;
            const word = document.getElementById('inputText').value.replace(/[^a-z0-9]/gi, '_');
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${word}_batak.gcode`;
            a.click();
        }
    </script>

</body>

</html>