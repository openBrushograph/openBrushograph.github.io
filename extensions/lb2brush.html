<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>G-code Optimizer & Converter</title>
    <style>
        body { font-family: sans-serif; background: #f0f2f5; padding: 20px; color: #333; }
        .container { max-width: 900px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h2 { color: #0056b3; margin-top: 0; }
        .form-row { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; }
        .form-group { margin-bottom: 5px; flex: 1 1 150px; min-width: 150px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="number"], input[type="text"], input[type="file"] { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
        textarea { width: 100%; height: 200px; font-family: "Fira Mono", "Consolas", monospace; font-size: 12px; box-sizing: border-box; border-radius: 4px; border: 1px solid #ccc; padding: 8px; }
        button { background: #0056b3; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px; width: 100%; margin-top: 10px; }
        button:hover { background: #004494; }
        button.download-btn { background: #28a745; display: none; }
        button.download-btn:hover { background: #218838; }
        #status {
            margin-top: 15px;
            padding: 10px;
            background: #000;
            color: #00ff66;
            border-radius: 4px;
            border: 1px solid #333;
            white-space: pre-wrap;
            display: none;
            max-height: 250px;
            overflow-y: auto;
            font-size: 12px;
            font-family: "Fira Mono", "Consolas", "Menlo", monospace;
        }
        .success { color: #00ff66; }
        .error { color: #ff5555; }
        .checkbox-group { display: flex; align-items: center; height: 100%; padding-top: 15px; }
        .checkbox-group input { width: auto; margin-right: 8px; }
        .checkbox-group label { margin: 0; cursor: pointer; }
        .small { font-size: 12px; color: #555; }
        canvas { border: 1px solid #ccc; background: #fff; image-rendering: pixelated; margin-top: 5px; }
        details { margin-top: 10px; margin-bottom: 10px; border: 1px solid #eee; padding: 10px; border-radius: 4px; }
        summary { cursor: pointer; font-weight: bold; color: #555; }
        h4 { margin-top: 10px; margin-bottom: 5px; color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }
    </style>
</head>
<body>
<div class="container">
    <h2>G-code Optimizer & Converter</h2>
    <p class="small">
        Converts G91 relative to G90 absolute, injects Z moves (S&rarr;Z), applies Backlash Fix, and optimizes Color Pickups.
    </p>

    <!-- File Input -->
    <div class="form-row">
        <div class="form-group">
            <label for="fileInput">Select G-code:</label>
            <input type="file" id="fileInput" accept=".gcode,.nc,.txt" onchange="onFileSelected()">
        </div>
    </div>

    <!-- Preview Settings -->
    <details>
        <summary>Preview Settings</summary>
        <div class="form-row">
            <div class="form-group">
                <label for="canvasWidth">Canvas Width (px):</label>
                <input type="number" id="canvasWidth" value="300">
            </div>
            <div class="form-group">
                <label for="canvasHeight">Canvas Height (px):</label>
                <input type="number" id="canvasHeight" value="280">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="xRange">X Range (mm):</label>
                <input type="number" id="xRange" value="150">
            </div>
            <div class="form-group">
                <label for="yRange">Y Range (mm):</label>
                <input type="number" id="yRange" value="140">
            </div>
            <div class="form-group">
                <label for="zThreshold">Z Paint Threshold (mm):</label>
                <input type="number" id="zThreshold" value="1.0" step="0.1">
            </div>
        </div>
    </details>

    <!-- Original Preview -->
    <div style="text-align: center;">
        <h4>Original G-code Preview</h4>
        <canvas id="previewCanvasOriginal" width="300" height="280"></canvas>
    </div>

    <!-- Settings Groups -->
    <div style="background: #f9f9f9; padding: 10px; border-radius: 4px; margin-top: 20px;">
        
        <!-- Step 1: Conversion & Z-Lift -->
        <h4>1. Conversion & Z-Lift</h4>
        <div class="form-row">
            <div class="form-group">
                <label for="zUp">Z Lift (mm) [S=0]:</label>
                <input type="number" id="zUp" value="5" step="0.1">
            </div>
            <div class="form-group">
                <label for="zDown">Z Paint (mm) [S>0]:</label>
                <input type="number" id="zDown" value="0" step="0.1">
            </div>
            <div class="form-group">
                <label for="zFeed">Z Feedrate (F):</label>
                <input type="number" id="zFeed" value="500" step="10">
            </div>
            <div class="form-group checkbox-group">
                <label><input type="checkbox" id="useG0" checked> Use G0 for Z</label>
            </div>
            <div class="form-group checkbox-group">
                <label><input type="checkbox" id="removeS"> Remove S</label>
            </div>
        </div>

        <!-- Step 2: Backlash -->
        <h4>2. Backlash Compensation</h4>
        <div class="form-row">
            <div class="form-group checkbox-group">
                <label><input type="checkbox" id="applyBacklash" checked> Apply Fix</label>
            </div>
            <div class="form-group">
                <label for="bx">Backlash X (mm):</label>
                <input type="number" id="bx" value="1.3" step="0.05">
            </div>
            <div class="form-group">
                <label for="by">Backlash Y (mm):</label>
                <input type="number" id="by" value="1.3" step="0.05">
            </div>
        </div>

        <!-- Step 3: Color Optimization -->
        <h4>3. Color Optimization</h4>
        <div class="form-row">
            <div class="form-group checkbox-group">
                <label><input type="checkbox" id="applyColorOpt" checked> Apply Color Opt</label>
            </div>
            <div class="form-group">
                <label for="distance">Distance (mm):</label>
                <input type="number" id="distance" value="100" step="1">
            </div>
            <div class="form-group">
                <label for="forceMultiplier">Multiplier:</label>
                <input type="number" id="forceMultiplier" value="2.0" step="0.1">
            </div>
            <div class="form-group checkbox-group">
                <label><input type="checkbox" id="aggressive"> Aggressive</label>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Layer Colors (Comma sep.):</label>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group"><input type="text" id="color1Layers" value="Green, C00, C1" placeholder="Color 1 Layers"></div>
            <div class="form-group"><input type="text" id="color2Layers" value="Blue, C2" placeholder="Color 2 Layers"></div>
            <div class="form-group"><input type="text" id="color3Layers" value="Red, C03, C3" placeholder="Color 3 Layers"></div>
            <div class="form-group"><input type="text" id="washLayers" value="Wash" placeholder="Wash Layers"></div>
        </div>
    </div>

    <!-- Actions -->
    <button onclick="runConvert()">Run Optimizer Pipeline</button>
    <div id="status"></div>

    <!-- Output Preview -->
    <div style="text-align: center; margin-top: 20px;">
        <h4>Optimized G-code Preview</h4>
        <canvas id="previewCanvasOptimized" width="300" height="280"></canvas>
    </div>

    <!-- Download -->
    <button id="downloadBtn" class="download-btn" onclick="downloadOptimized()">Download Optimized G-code</button>

    <!-- Text Areas (Collapsible) -->
    <details>
        <summary>View G-code Text</summary>
        <h3>Input</h3>
        <textarea id="inputText" placeholder="Original G-code..."></textarea>
        <h3>Output</h3>
        <textarea id="outputText" placeholder="Converted G-code..."></textarea>
    </details>
</div>

<script>
// === Globals ===
let LAST_ORIGINAL_TEXT = null;
let LAST_OPTIMIZED_TEXT = null;
let LAST_FILENAME = "optimized.gcode";

// === Constants for Preview ===
const PREVIEW_DEFAULT_X_RANGE = 150.0;
const PREVIEW_DEFAULT_Y_RANGE = 140.0;
const PREVIEW_DEFAULT_Z_THRESHOLD = 1.0;
const PREVIEW_PALETTE = ['#0066ff', '#ff00aa', '#00c800']; 
const PREVIEW_COLOR_PICK_COMMENT = 'Color picking sequence';
const PREVIEW_WASH_COMMENT = 'Washing sequence (no color)';

// === Sequences ===
const HOMING_SEQUENCE = `
G0 Z10 F500;      ; Move to clearance level
; G0 X-10 Y-10 F1200; Homing
; G0 X-5 Y-5 F1200; go in
; G10 P0 L20 X0 Y0; set to zero
G1 F1200;           ; Set feed rate
`;

const COLOR1_SEQUENCE = `
; Color picking sequence
G1 Z10 F1000;         ; Raise brush
G0 X41 Y5 F1200;    ; Rapid move to color 1
G1 Z10 F1000;         ; Raise brush
G0 X41 Y5 F1200;    ; Rapid move to color 1
G1 Z0 F1000;         ; Lower into color
G1 X40.102 Y7.295 Z0 S800 F1200
G1 X40.026 Y7.642 Z0 F1200
G1 X40 Y8 Z0 F1200
G1 X40.026 Y8.358 Z0 F1200
G1 X40.102 Y8.705 Z0 F1200
G1 X40.225 Y9.041 Z0 F1200
G1 X40.393 Y9.362 Z0 F1200
G1 X40.603 Y9.668 Z0 F1200
G1 X40.854 Y9.957 Z0 F1200
G1 X41.142 Y10.226 Z0 F1200
G1 X41.464 Y10.475 Z0 F1200
G1 X41.82 Y10.701 Z0 F1200
G1 X42.204 Y10.902 Z0 F1200
G1 X42.617 Y11.078 Z0 F1200
G1 X43.054 Y11.225 Z0 F1200
G1 X43.513 Y11.343 Z0 F1200
G1 X43.992 Y11.429 Z0 F1200
G1 X44.489 Y11.482 Z0 F1200
G1 X45 Y11.5 Z0 F1200
G1 X45.511 Y11.482 Z0 F1200
G1 X46.008 Y11.429 Z0 F1200
G1 X46.487 Y11.343 Z0 F1200
G1 X46.946 Y11.225 Z0 F1200
G1 X47.383 Y11.078 Z0 F1200
G1 X47.796 Y10.902 Z0 F1200
G1 X48.18 Y10.701 Z0 F1200
G1 X48.536 Y10.475 Z0 F1200
G1 X48.858 Y10.226 Z0 F1200
G1 X49.146 Y9.957 Z0 F1200
G1 X49.397 Y9.668 Z0 F1200
G1 X49.607 Y9.362 Z0 F1200
G1 X49.775 Y9.041 Z0 F1200
G1 X49.898 Y8.705 Z0 F1200
G1 X49.974 Y8.358 Z0 F1200
G1 X50 Y8 Z0 F1200
G1 X49.974 Y7.642 Z0 F1200
G1 X49.898 Y7.295 Z0 F1200
G1 X49.775 Y6.959 Z0 F1200
G1 X49.607 Y6.638 Z0 F1200
G1 X49.397 Y6.332 Z0 F1200
G1 X49.146 Y6.043 Z0 F1200
G1 X48.858 Y5.774 Z0 F1200
G1 X48.536 Y5.525 Z0 F1200
G1 X48.18 Y5.299 Z0 F1200
G1 X47.796 Y5.098 Z0 F1200
G1 X47.383 Y4.922 Z0 F1200
G1 X46.946 Y4.775 Z0 F1200
G1 X46.487 Y4.657 Z0 F1200
G1 X46.008 Y4.571 Z0 F1200
G1 X45.511 Y4.518 Z0 F1200
G1 X45 Y4.5 Z0 F1200
G1 X44.489 Y4.518 Z0 F1200
G1 X43.992 Y4.571 Z0 F1200
G1 X43.513 Y4.657 Z0 F1200
G1 X43.054 Y4.775 Z0 F1200
G1 X42.617 Y4.922 Z0 F1200
G1 X42.204 Y5.098 Z0 F1200
G1 X41.82 Y5.299 Z0 F1200
G1 X41.464 Y5.525 Z0 F1200
G1 X41.142 Y5.774 Z0 F1200
G1 X40.854 Y6.043 Z0 F1200
G1 X40.603 Y6.332 Z0 F1200
G1 X40.393 Y6.638 Z0 F1200
G1 X40.225 Y6.959 Z0 F1200
G1 Z7 F800;         ; Raise from color
G1 X34 Y8 Z1 F1200;     ; Movement in paint
G1 X24 Y18 Z8 F500;     ; Move in paint
G1 F1200;           ; Set feed rate
`;

function offsetXInGcodeBlock(block, dx) {
    const pattern = /X(\s*)(-?\d+(?:\.\d+)?)/g;
    return block.replace(pattern, (match, space, orig) => {
        let decimals = 0;
        if (orig.includes('.')) {
            decimals = orig.split('.')[1].length;
        }
        let newVal = parseFloat(orig) + dx;
        if (Number.isNaN(newVal)) return match;
        if (decimals > 0) {
            return `X${space}${newVal.toFixed(decimals)}`;
        } else {
            return `X${space}${Math.round(newVal)}`;
        }
    });
}

const COLOR2_SEQUENCE = offsetXInGcodeBlock(COLOR1_SEQUENCE, 45);
const COLOR3_SEQUENCE = offsetXInGcodeBlock(COLOR1_SEQUENCE, 90);

const WASHING_SEQUENCE = `
; Washing sequence (no color)
G1 Z10 F1000;        ; Raise brush
G0 X5 Y5 F1200;     ; Rapid move to clean
G1 Z-1 F800;         ; Lower brush
G1 X10 Y12 Z8 F1200;     ; Move
G1 Z-1 F800;         ; Lower
G1 X25 Y14 Z6 F800;     ; Move
G1 Z8 F800;         ; Maintain
G0 X5 Y5 F1200;     ; Rapid
G1 Z-1 F800;         ; Lower
G1 X15 Y12 Z8 F1200;     ; Move
G1 Z-1 F800;         ; Lower
G1 X25 Y14 Z6 F800;     ; Move
G1 Z10 F800;         ; Maintain
G1 F1200;           ; Set feed
`;

const ENDING_SEQUENCE = `
; Return to 2,0 wash and park
G1 Z10 F1000;        ; Raise brush
G0 X5 Y5 F1200;     ; Rapid move to clean
G1 Z-1 F800;         ; Lower brush
G1 X10 Y12 Z8 F1200;     ; Move
G1 Z-1 F800;         ; Lower
G1 X25 Y14 Z6 F800;     ; Move
G0 X5 Y5 F1200;     ; Rapid
G1 Z-1 F800;         ; Lower
G1 X15 Y12 Z8 F1200;     ; Move
G1 Z-1 F800;         ; Lower
G1 X25 Y14 Z6 F800;     ; Move
G1 Z10 F800;         ; Maintain
G0 X20 Y130 Z10 F500;; Move to park
M2;                 ; End program
`;

// Default Layer Map
const DEFAULT_LAYER_COLOR_MAP = {
    "Green": { sequence: COLOR1_SEQUENCE, name: "Color 1" },
    "Blue":  { sequence: COLOR2_SEQUENCE, name: "Color 2" },
    "Red":   { sequence: COLOR3_SEQUENCE, name: "Color 3" },
    "C03":   { sequence: COLOR3_SEQUENCE, name: "Color 3" },
    "C00":   { sequence: COLOR1_SEQUENCE, name: "Color 1" },
    "C1":    { sequence: COLOR1_SEQUENCE, name: "Color 1" },
    "C2":    { sequence: COLOR2_SEQUENCE, name: "Color 2" },
    "C3":    { sequence: COLOR3_SEQUENCE, name: "Color 3" },
    "Wash":  { sequence: WASHING_SEQUENCE, name: "Washing" },
    "default": { sequence: WASHING_SEQUENCE, name: "Washing" }
};

// === Helper Functions ===
function fmt(n) {
    let s = n.toFixed(3);
    return s.replace(/\.?0+$/, "");
}

function parseLayerList(text) {
    if (!text) return [];
    return text.split(',').map(s => s.trim()).filter(s => s.length > 0);
}

function buildLayerColorMapFromUI() {
    const map = { ...DEFAULT_LAYER_COLOR_MAP };
    const c1 = parseLayerList(document.getElementById('color1Layers')?.value || "");
    const c2 = parseLayerList(document.getElementById('color2Layers')?.value || "");
    const c3 = parseLayerList(document.getElementById('color3Layers')?.value || "");
    const cw = parseLayerList(document.getElementById('washLayers')?.value   || "");

    function assignLayers(layerNames, sequence, name) {
        for (const ln of layerNames) {
            map[ln] = { sequence, name };
        }
    }

    if (c1.length) assignLayers(c1, COLOR1_SEQUENCE, "Color 1");
    if (c2.length) assignLayers(c2, COLOR2_SEQUENCE, "Color 2");
    if (c3.length) assignLayers(c3, COLOR3_SEQUENCE, "Color 3");
    if (cw.length) assignLayers(cw, WASHING_SEQUENCE, "Washing");

    return map;
}

function nextZLiftInRange(lines, startIndex, maxLookahead) {
    // Look for any move with Z > 0 (assuming Z0 is paint)
    // Matches Z followed by non-zero digit, or Z followed by 0.something non-zero
    const re = /Z\s*[1-9]|Z\s*0\.[1-9]/; 
    const endIndex = Math.min(startIndex + maxLookahead, lines.length);
    for (let i = startIndex; i < endIndex; i++) {
        // Must check if it's a move command
        if (/G[01]/.test(lines[i]) && re.test(lines[i])) return i - startIndex;
    }
    return null;
}

// === Backlash Fixer ===
class RF_FluidNCSafeBacklash {
    constructor(bx, by, threshold = 0.05, safeFeed = 200) {
        this.bx = bx;
        this.by = by;
        this.threshold = threshold;
        this.safeFeed = safeFeed;
        this.current_x = 0.0;
        this.current_y = 0.0;
        this.offset_x = 0.0;
        this.offset_y = 0.0;
        this.dir_x = 0;
        this.dir_y = 0;
    }

    processLine(originalLine, currentFeed) {
        // Since input is already absolute, we don't handle G91 switching here
        let newLines = [];
        let line = originalLine.trim();
        if (!line || line.startsWith(';')) return { lines: [originalLine], newFeed: currentFeed };

        let target_x = this.current_x;
        let target_y = this.current_y;
        let has_move = false;
        let nextFeed = currentFeed;

        const rx = /X([-\d.]+)/;
        const ry = /Y([-\d.]+)/;
        const rf = /F([-\d.]+)/;

        let mx = line.match(rx);
        if (mx) { target_x = parseFloat(mx[1]); has_move = true; }
        
        let my = line.match(ry);
        if (my) { target_y = parseFloat(my[1]); has_move = true; }
        
        let mf = line.match(rf);
        if (mf) { nextFeed = parseFloat(mf[1]); }

        if (!has_move) return { lines: [originalLine], newFeed: nextFeed };

        let dx = target_x - this.current_x;
        if (Math.abs(dx) > this.threshold) {
            let new_dir_x = dx > 0 ? 1 : -1;
            if (this.dir_x !== 0 && new_dir_x !== this.dir_x) {
                let change = new_dir_x === 1 ? this.bx : -this.bx;
                this.offset_x += change;
                let phys_x = this.current_x + this.offset_x;
                if (phys_x < 0) phys_x = 0; // Safety
                let phys_y = this.current_y + this.offset_y;
                newLines.push(`; --- FIX X Backlash ---`);
                newLines.push(`G0 X${fmt(phys_x)} Y${fmt(phys_y)} F${this.safeFeed}`);
            }
            this.dir_x = new_dir_x;
        }

        let dy = target_y - this.current_y;
        if (Math.abs(dy) > this.threshold) {
            let new_dir_y = dy > 0 ? 1 : -1;
            if (this.dir_y !== 0 && new_dir_y !== this.dir_y) {
                let change = new_dir_y === 1 ? this.by : -this.by;
                this.offset_y += change;
                let phys_x = this.current_x + this.offset_x;
                let phys_y = this.current_y + this.offset_y;
                if (phys_y < 0) phys_y = 0; // Safety
                newLines.push(`; --- FIX Y Backlash ---`);
                newLines.push(`G0 X${fmt(phys_x)} Y${fmt(phys_y)} F${this.safeFeed}`);
            }
            this.dir_y = new_dir_y;
        }

        let final_x = target_x + this.offset_x;
        let final_y = target_y + this.offset_y;
        if (final_x < 0) final_x = 0;
        if (final_y < 0) final_y = 0;

        // Reconstruct line with new coords
        // Simple Replace for this specific file structure since it's already normalized by step 1
        let newLine = line;
        if (mx) newLine = newLine.replace(rx, `X${fmt(final_x)}`);
        if (my) newLine = newLine.replace(ry, `Y${fmt(final_y)}`);
        
        // Remove old Z if present (just to be safe, though Step 1 handles Z)
        // Actually, Step 1 puts Z in. We should preserve Z.
        // We only modify X and Y here.
        
        newLines.push(newLine);
        this.current_x = target_x;
        this.current_y = target_y;

        return { lines: newLines, newFeed: nextFeed };
    }
}

// === Color Optimizer ===
function optimizeGcodeText(lines, options) {
    const { distanceThreshold, forceMultiplier, aggressive, layerColorMap, zUp } = options;
    const safeZ = zUp || 5.0;
    
    let output_lines = [];
    output_lines.push(HOMING_SEQUENCE); // Homing at start

    let total_length = 0;
    let accumulated_length = 0;
    let current_x = 0, current_y = 0;
    let current_layer = "default";
    let previous_layer = null;
    let color_pickup_count = { "Color 1": 0, "Color 2": 0, "Color 3": 0, "Washing": 0 };
    let current_color_sequence = WASHING_SEQUENCE;
    let current_color_name = "Washing";
    let last_color_name = null;
    let is_drawing = false;
    let pickup_segments = [];
    let debug_log = [];

    // Robust Regex for Layer
    const coordXRegex = /X([-\d.]+)/;
    const coordYRegex = /Y([-\d.]+)/;
    const layer_regex = /;\s*Layer\s+(\w+)/i; 
    const m8_regex = /M8/i;
    const op_start_regex = /^;(Scan|Offset|Cut)/i;

    function log(msg) {
        if (debug_log.length < 500) debug_log.push(`L${output_lines.length}: ${msg}`);
    }

    for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();
        if (!line) {
            output_lines.push("\n");
            continue;
        }

        // Detect Start of Operation Block (M8 or ;Scan/Offset/Cut)
        if (m8_regex.test(line) || op_start_regex.test(line)) {
            let next_layer = null;
            // Look ahead up to 20 lines for a Layer tag
            for(let j=1; j<=20; j++) {
                if (i+j < lines.length && layer_regex.test(lines[i+j])) {
                    next_layer = lines[i+j].match(layer_regex)[1];
                    break;
                }
            }
            if (next_layer && layerColorMap[next_layer]) {
                current_layer = next_layer;
                if (current_layer !== previous_layer) {
                    accumulated_length = 0;
                    current_color_sequence = layerColorMap[current_layer].sequence;
                    current_color_name = layerColorMap[current_layer].name;
                    
                    if (last_color_name && last_color_name !== current_color_name) {
                        output_lines.push(WASHING_SEQUENCE);
                        output_lines.push(`G0 Z${fmt(safeZ)} F1000 ; Safety Lift\n`);
                        color_pickup_count["Washing"]++;
                    }
                    output_lines.push(current_color_sequence);
                    output_lines.push(`G0 Z${fmt(safeZ)} F1000 ; Safety Lift\n`);
                    color_pickup_count[current_color_name]++;
                    previous_layer = current_layer;
                    last_color_name = current_color_name;
                    log(`Layer change to ${current_layer}. Pickup ${current_color_name}.`);
                }
            }
            output_lines.push(line + "\n");
            continue;
        }

        // Layer Tag Detection (Fallback or subsequent tags)
        let layer_match = line.match(layer_regex);
        if (layer_match) {
            current_layer = layer_match[1];
            // Allow switch if layer matches map and hasn't been handled by M8 block immediately preceding
            if (current_layer !== previous_layer) {
                if (layerColorMap[current_layer]) {
                    accumulated_length = 0;
                    current_color_sequence = layerColorMap[current_layer].sequence;
                    current_color_name = layerColorMap[current_layer].name;
                    
                    if (last_color_name && last_color_name !== current_color_name) {
                        output_lines.push(WASHING_SEQUENCE);
                        output_lines.push(`G0 Z${fmt(safeZ)} F1000 ; Safety Lift\n`);
                        color_pickup_count["Washing"]++;
                    }
                    output_lines.push(current_color_sequence);
                    output_lines.push(`G0 Z${fmt(safeZ)} F1000 ; Safety Lift\n`);
                    color_pickup_count[current_color_name]++;
                    previous_layer = current_layer;
                    last_color_name = current_color_name;
                    log(`Layer tag ${current_layer}. Pickup ${current_color_name}.`);
                }
            }
            output_lines.push(line + "\n");
            continue;
        }

        // Check Drawing State
        // Assume Z > 0 is NOT drawing (lift/travel)
        if (/G[01]/.test(line) && (/Z\s*[1-9]/.test(line) || /Z\s*0\.[1-9]/.test(line))) {
            is_drawing = false;
        }
        // Assume Z0 (or close to 0) IS drawing.
        // Allow G0 or G1. Step 1 might generate G0 Z0.
        if (/G[01]/.test(line) && /Z\s*0(\s|;|$)/.test(line)) {
            is_drawing = true;
        }

        // Parse Movement
        let xMatch = line.match(coordXRegex);
        let yMatch = line.match(coordYRegex);
        
        let prevX = current_x;
        let prevY = current_y;
        
        if (xMatch) current_x = parseFloat(xMatch[1]);
        if (yMatch) current_y = parseFloat(yMatch[1]);
        
        output_lines.push(line + "\n");

        // Distance Calculation
        if ((prevX !== 0 || prevY !== 0) && is_drawing && line.includes('G1') && (xMatch || yMatch)) {
            let dx = current_x - prevX;
            let dy = current_y - prevY;
            let dist = Math.sqrt(dx*dx + dy*dy);
            total_length += dist;
            accumulated_length += dist;

            if (accumulated_length > distanceThreshold) {
                let is_clean_transition = false;
                let force_pickup = false;

                if (aggressive) {
                    if (/G[01]/.test(line)) is_clean_transition = true;
                } else {
                    // Check for Z lift next
                    let nextZ = nextZLiftInRange(lines, i+1, 20);
                    if (nextZ != null && nextZ < 10) {
                        // Will lift soon, wait
                        // log(`Wait for lift in ${nextZ} lines. Acc: ${accumulated_length.toFixed(1)}`);
                    } else if (accumulated_length >= (forceMultiplier * distanceThreshold)) {
                        force_pickup = true;
                        is_clean_transition = true; // Force it
                        log(`Force pickup. Acc: ${accumulated_length.toFixed(1)}`);
                    }
                }

                if (is_clean_transition) {
                    if (last_color_name && last_color_name !== current_color_name) {
                        output_lines.push(WASHING_SEQUENCE);
                        output_lines.push(`G0 Z${fmt(safeZ)} F1000 ; Safety Lift\n`);
                        color_pickup_count["Washing"]++;
                    }
                    output_lines.push(current_color_sequence);
                    output_lines.push(`G0 Z${fmt(safeZ)} F1000 ; Safety Lift\n`);
                    color_pickup_count[current_color_name]++;
                    
                    pickup_segments.push([current_layer, current_color_name, accumulated_length]);
                    accumulated_length = 0;
                    
                    // Return to position if we forced a pickup mid-stream
                    if (force_pickup) {
                        output_lines.push(`G0 X${fmt(current_x)} Y${fmt(current_y)} F1200 ; Return\n`);
                        output_lines.push(`G1 Z0 F1000 ; Restore Z\n`);
                    }
                }
            }
        }

        // CATCH-ALL: Pending Pickup on Z-Lifts (Clean Transition)
        // Trigger if accumulated length > threshold AND current line is a Z-lift (Z > 0)
        // This catches cases where we skipped the pickup above because a lift was "coming soon"
        if (accumulated_length > distanceThreshold && /G[01]/.test(line) && (/Z\s*[1-9]/.test(line) || /Z\s*0\.[1-9]/.test(line))) {
            log(`Catch-All Triggered! Acc: ${accumulated_length.toFixed(1)} on line: ${line.trim()}`);
            if (last_color_name && last_color_name !== current_color_name) {
                output_lines.push(WASHING_SEQUENCE);
                output_lines.push(`G0 Z${fmt(safeZ)} F1000 ; Safety Lift\n`);
                color_pickup_count["Washing"]++;
            }
            output_lines.push(current_color_sequence);
            output_lines.push(`G0 Z${fmt(safeZ)} F1000 ; Safety Lift\n`);
            // CRITICAL FIX: Return to the pre-pickup position (X, Y) because the next G-code line might rely on inherited coordinates
            output_lines.push(`G0 X${fmt(current_x)} Y${fmt(current_y)} F1200 ; Return to pos\n`);
            
            color_pickup_count[current_color_name]++;
            
            pickup_segments.push([current_layer, current_color_name, accumulated_length]);
            accumulated_length = 0;
            // No return/restore needed as we are at a natural break
        }
    }

    output_lines.push(ENDING_SEQUENCE);
    
    // Generate Report
    let final_joined_text = output_lines.join("");
    let estimated_time_str = estimateTime(final_joined_text.split('\n'));

    let report = [];
    report.push(`Total drawing path length: ${total_length.toFixed(2)} mm (${(total_length/1000).toFixed(2)} m)`);
    report.push(`Estimated Time: ${estimated_time_str}`);
    report.push("");
    report.push("Color Pickup Insertions:");
    for (const [color, count] of Object.entries(color_pickup_count)) {
        if (count > 0) report.push(`  ${color}: ${count} pickups`);
    }
    report.push("");
    report.push("Path Segments Between Pickups:");
    for (const seg of pickup_segments) {
        report.push(`  Layer ${seg[0]}, Color ${seg[1]}: ${seg[2].toFixed(2)} mm`);
    }
    report.push("");
    report.push("Debug Log (First 500 entries):");
    report.push(debug_log.join("\n"));

    return { optimizedText: final_joined_text, report: report.join("\n") };
}

function estimateTime(lines) {
    let x = 0, y = 0, z = 0;
    let f = 1000; // Default feedrate
    let totalSeconds = 0;

    const rx = /X([-\d.]+)/;
    const ry = /Y([-\d.]+)/;
    const rz = /Z([-\d.]+)/;
    const rf = /F([-\d.]+)/;

    for (let line of lines) {
        line = line.trim();
        if (!line || line.startsWith(';')) continue;

        // Parse Feedrate
        let mf = line.match(rf);
        if (mf) f = parseFloat(mf[1]);
        if (f <= 0) f = 1000; // Prevent divide by zero

        // Parse G4 Dwell
        if (line.startsWith('G4')) {
            let mp = line.match(/P([-\d.]+)/);
            if (mp) {
                // Assuming P is seconds if using Marlin/standard, or ms?
                // LightBurn often uses P as seconds for G4. 
                // Let's assume seconds.
                totalSeconds += parseFloat(mp[1]); 
            }
            continue;
        }

        // Parse Moves
        if (line.startsWith('G0') || line.startsWith('G1')) {
            let nx = x, ny = y, nz = z;
            let mx = line.match(rx);
            if (mx) nx = parseFloat(mx[1]);
            let my = line.match(ry);
            if (my) ny = parseFloat(my[1]);
            let mz = line.match(rz);
            if (mz) nz = parseFloat(mz[1]);

            let dx = nx - x;
            let dy = ny - y;
            let dz = nz - z;
            let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            if (dist > 0) {
                // Time = Distance / Speed
                // Speed is F (mm/min). So mm/sec = F/60.
                totalSeconds += dist / (f / 60.0);
            }

            x = nx; y = ny; z = nz;
        }
    }

    // Format time
    let h = Math.floor(totalSeconds / 3600);
    let m = Math.floor((totalSeconds % 3600) / 60);
    let s = Math.floor(totalSeconds % 60);

    let parts = [];
    if (h > 0) parts.push(`${h}h`);
    if (m > 0) parts.push(`${m}m`);
    parts.push(`${s}s`);
    
    return parts.join(" ");
}

// === Pipeline ===
function runConvert() {
    const statusDiv = document.getElementById('status');
    const outputArea = document.getElementById('outputText');
    const canvasOptimized = document.getElementById('previewCanvasOptimized');
    const downloadBtn = document.getElementById('downloadBtn');

    if (!LAST_ORIGINAL_TEXT) {
        statusDiv.textContent = 'Please select a file first.';
        return;
    }

    // Settings
    const zOpts = {
        zUp: parseFloat(document.getElementById('zUp').value) || 5,
        zDown: parseFloat(document.getElementById('zDown').value) || 0,
        zFeed: parseFloat(document.getElementById('zFeed').value) || 500,
        useG0: document.getElementById('useG0').checked,
        removeS: document.getElementById('removeS').checked
    };
    
    const applyBacklash = document.getElementById('applyBacklash').checked;
    const bx = parseFloat(document.getElementById('bx').value) || 0.5;
    const by = parseFloat(document.getElementById('by').value) || 0.5;

    const applyColorOpt = document.getElementById('applyColorOpt').checked;
    const colorOpts = {
        distanceThreshold: parseFloat(document.getElementById('distance').value) || 100,
        forceMultiplier: parseFloat(document.getElementById('forceMultiplier').value) || 2.0,
        aggressive: document.getElementById('aggressive').checked,
        layerColorMap: buildLayerColorMapFromUI(),
        analyzeOnly: false,
        zUp: zOpts.zUp
    };

    try {
        const lines = LAST_ORIGINAL_TEXT.split(/\r?\n/);
        
        // Step 1: Relative -> Absolute, S->Z
        let absLines = convertRelativeToAbsolute(lines, zOpts);

        // Step 2: Backlash (Run BEFORE Color Opt so paint sequences aren't shifted)
        let processedLines = absLines;
        if (applyBacklash) {
            const fixer = new RF_FluidNCSafeBacklash(bx, by, 0.05, 1200);
            let fixedLines = [];
            let currentFeed = 500;
            for (const line of absLines) {
                const l = line.replace(/\n$/, "");
                const res = fixer.processLine(l, currentFeed);
                currentFeed = res.newFeed;
                for (const rl of res.lines) fixedLines.push(rl + "\n");
            }
            processedLines = fixedLines;
        }

        // Step 3: Color Optimization (Run LAST)
        let finalOutput = "";
        let report = "";
        
        if (applyColorOpt) {
            const result = optimizeGcodeText(processedLines, colorOpts);
            finalOutput = result.optimizedText;
            report = result.report;
        } else {
            finalOutput = processedLines.join("");
            report = "Color optimization disabled.\nBacklash fix and conversion applied.";
        }
        
        LAST_OPTIMIZED_TEXT = finalOutput;
        outputArea.value = LAST_OPTIMIZED_TEXT;
        
        statusDiv.style.display = 'block';
        statusDiv.innerHTML = `<span class="success">Pipeline Complete!</span>\n\n` + report;
        
        renderPreviewFor(LAST_OPTIMIZED_TEXT, canvasOptimized);
        downloadBtn.style.display = 'inline-block';
        
    } catch (err) {
        console.error(err);
        statusDiv.style.display = 'block';
        statusDiv.innerHTML = '<span class="error">Error: ' + err.message + '</span>';
    }
}

// === Core Convert Logic (Step 1) ===
function convertRelativeToAbsolute(lines, opts) {
    let out = [];
    let x = 0.0, y = 0.0, z = 0.0;
    let isRelative = false;
    let isRaised = false;
    let inScanSection = false;
    const { zUp, zDown, zFeed, useG0, removeS } = opts;
    
    out.push("G90 ; Force absolute mode\n");
    
    for (let line of lines) {
        let trimmed = line.trim();
        if (!trimmed) { out.push("\n"); continue; }
        
        let content = trimmed;
        let comment = "";
        let semiIdx = trimmed.indexOf(';');
        if (semiIdx >= 0) {
            content = trimmed.substring(0, semiIdx).trim();
            comment = trimmed.substring(semiIdx);
        }

        if (comment) {
            if (/\bScan\b/i.test(comment)) inScanSection = true;
            if (/\b(Offset|Cut)\b/i.test(comment)) { inScanSection = false; isRaised = false; }
        }
        
        if (!content) { out.push(comment + "\n"); continue; }
        
        if (/\bG90\b/i.test(content)) isRelative = false;
        if (/\bG91\b/i.test(content)) isRelative = true;
        
        // S->Z logic
        let sMatch = content.match(/S\s*([-\d.]+)/i);
        let sBasedZ = null; // Track if we set Z based on S

        if (sMatch && inScanSection) {
            let sVal = parseFloat(sMatch[1]);
            let needsUp = (sVal === 0);
            let needsDown = (sVal > 0);
            let zCmd = useG0 ? "G0" : "G1";
            let zF = (zFeed > 0) ? ` F${zFeed}` : "";
            
            if (needsUp && !isRaised) {
                z = zUp; 
                out.push(`${zCmd} Z${fmt(z)}${zF} ; Lift S=0\n`);
                isRaised = true;
                sBasedZ = z;
            } else if (needsDown && isRaised) {
                z = zDown;
                out.push(`${zCmd} Z${fmt(z)}${zF} ; Drop S>0\n`);
                isRaised = false;
                sBasedZ = z;
            } else if (needsUp && isRaised) {
                 sBasedZ = zUp;
            } else if (needsDown && !isRaised) {
                 sBasedZ = zDown;
            }
        }

        let moveMatch = content.match(/\b(G0|G1)\b/i);
        if (moveMatch) {
            let type = moveMatch[1].toUpperCase();
            let xm = content.match(/X([-\d.]+)/i);
            let ym = content.match(/Y([-\d.]+)/i);
            let zm = content.match(/Z([-\d.]+)/i);
            let hasMove = xm || ym || zm;
            
            // Check if we should ignore Z for this line (only if S is controlling Z in scan)
            // We ignore Z if we are in scan section AND (we have an S command OR we just set Z via S-logic)
            // sm is not defined yet, let's look ahead or use sMatch
            let ignoreZ = inScanSection && (sMatch || sBasedZ !== null);

            if (hasMove) {
                if (isRelative) {
                    if (xm) x += parseFloat(xm[1]);
                    if (ym) y += parseFloat(ym[1]);
                    if (zm && !ignoreZ) z += parseFloat(zm[1]);
                } else {
                    if (xm) x = parseFloat(xm[1]);
                    if (ym) y = parseFloat(ym[1]);
                    if (zm && !ignoreZ) z = parseFloat(zm[1]);
                }

                // If in scan section, ensure Z tracks our S-based state (redundant but safe)
                if (inScanSection && sBasedZ !== null) z = sBasedZ;
                
                let fm = content.match(/F([-\d.]+)/i);
                let sm = content.match(/S([-\d.]+)/i);
                
                let newLine = type;
                if (xm) newLine += ` X${fmt(x)}`;
                if (ym) newLine += ` Y${fmt(y)}`;
                
                // Output Z only if we didn't ignore it
                if (!ignoreZ && zm) newLine += ` Z${fmt(z)}`;
                
                if (sm && !removeS) newLine += ` S${sm[1]}`;
                if (fm) newLine += ` F${fm[1]}`;
                
                out.push(newLine + (comment ? " " + comment : "") + "\n");
            } else {
                let clean = content.replace(/\bG9[01]\b/gi, "").replace(/\s+/g, ' ').trim();
                if (removeS) clean = clean.replace(/S\s*[-\d.]+/gi, "").trim();
                if (clean) out.push(clean + (comment ? " " + comment : "") + "\n");
                else if (comment) out.push(comment + "\n");
            }
        } else {
            let clean = content.replace(/\bG9[01]\b/gi, "").replace(/\s+/g, ' ').trim();
            if (removeS) clean = clean.replace(/S\s*[-\d.]+/gi, "").trim();
            if (clean) out.push(clean + (comment ? " " + comment : "") + "\n");
            else if (comment) out.push(comment + "\n");
        }
    }
    return out;
}

// === UI Handlers ===
function onFileSelected() {
    const fileInput = document.getElementById('fileInput');
    const statusDiv = document.getElementById('status');
    const canvasOriginal = document.getElementById('previewCanvasOriginal');
    const downloadBtn = document.getElementById('downloadBtn');

    LAST_ORIGINAL_TEXT = null;
    LAST_OPTIMIZED_TEXT = null;
    downloadBtn.style.display = 'none';

    if (!fileInput.files.length) return;
    const file = fileInput.files[0];
    const reader = new FileReader();
    statusDiv.textContent = 'Loading file for preview...';
    reader.onload = function(e) {
        LAST_ORIGINAL_TEXT = e.target.result;
        document.getElementById('inputText').value = LAST_ORIGINAL_TEXT;
        renderPreviewFor(LAST_ORIGINAL_TEXT, canvasOriginal);
        statusDiv.textContent = `Loaded ${file.name}. Ready to convert.`;
        LAST_FILENAME = "optimized_" + file.name.replace(/\.gcode$/i, "") + ".gcode";
    };
    reader.readAsText(file);
}

function downloadOptimized() {
    if (!LAST_OPTIMIZED_TEXT) {
        alert("No converted G-code available.");
        return;
    }
    const blob = new Blob([LAST_OPTIMIZED_TEXT], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = LAST_FILENAME;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// === Preview Logic ===
function previewParseXY(line, currentX, currentY, relative) {
    const xMatch = line.match(/X(-?\d+\.?\d*)/);
    const yMatch = line.match(/Y(-?\d+\.?\d*)/);
    let x = currentX;
    let y = currentY;
    if (xMatch) {
        const val = parseFloat(xMatch[1]);
        x = relative ? currentX + val : val;
    }
    if (yMatch) {
        const val = parseFloat(yMatch[1]);
        y = relative ? currentY + val : val;
    }
    return { x, y };
}

function previewParseZ(line, currentZ, relative) {
    const zMatch = line.match(/Z(-?\d+\.?\d*)/);
    if (!zMatch) return currentZ;
    const val = parseFloat(zMatch[1]);
    return relative ? currentZ + val : val;
}

function previewExtractSegments(text, zThreshold, xRangeMm, yRangeMm) {
    const lines = text.split(/\r?\n/);
    const segments = []; // [x1,y1,x2,y2,colorIndex]

    let currentX = 0.0;
    let currentY = 0.0;
    let currentZ = 10.0;
    let relative = false;
    let painting = false;
    let currentColor = null;
    let awaitingColorPick = false;
    let sawColorPickComment = false;

    for (let raw of lines) {
        const line = raw.trim();

        if (!line || line.startsWith(';')) {
            if (line.includes(PREVIEW_COLOR_PICK_COMMENT)) {
                sawColorPickComment = true;
                awaitingColorPick = true;
                painting = false;
            } else if (line.includes(PREVIEW_WASH_COMMENT)) {
                currentColor = null;
                painting = false;
                awaitingColorPick = false;
            }
            continue;
        }

        if (line.startsWith('G90')) {
            relative = false;
            continue;
        }
        if (line.startsWith('G91')) {
            relative = true;
            continue;
        }

        let newZ = currentZ;
        if (line.includes('Z')) {
            newZ = previewParseZ(line, currentZ, relative);
        }

        if ((line.startsWith('G0') || line.startsWith('G1')) && (line.includes('X') || line.includes('Y'))) {
            const { x: newX, y: newY } = previewParseXY(line, currentX, currentY, relative);

            // Color well detection near bottom palette area (Y small)
            if (awaitingColorPick && line.includes('G1') && newZ <= zThreshold && newY <= 20) {
                // Approximate well centers from lb2colour: Xâ‰ˆ45, 90, 135
                if (newX < 67.5) {
                    currentColor = 0; // left well (Color 1)
                } else if (newX < 112.5) {
                    currentColor = 1; // middle well (Color 2)
                } else {
                    currentColor = 2; // right well (Color 3)
                }
                awaitingColorPick = false;
            }

            // Single-color files without explicit color-pick comments
            if (!sawColorPickComment && currentColor === null && newZ <= zThreshold) {
                currentColor = 0;
            }

            painting = currentColor !== null && newZ <= zThreshold;

            if (painting) {
                segments.push([currentX, currentY, newX, newY, currentColor !== null ? currentColor : 0]);
            }

            currentX = newX;
            currentY = newY;
            currentZ = newZ;
            continue;
        }

        if (line.includes('Z') && !(line.includes('X') || line.includes('Y'))) {
            currentZ = newZ;
        }
    }

    return segments;
}

function previewMapToPixels(x, y, widthPx, heightPx, xRangeMm, yRangeMm) {
    const xr = xRangeMm || PREVIEW_DEFAULT_X_RANGE;
    const yr = yRangeMm || PREVIEW_DEFAULT_Y_RANGE;

    const xClamped = Math.max(0, Math.min(xr, x));
    const yClamped = Math.max(0, Math.min(yr, y));

    const u = xClamped / xr;
    const v = yClamped / yr;

    const px = u * (widthPx - 1);
    const py = (1 - v) * (heightPx - 1); // Invert Y
    return { px: Math.round(px), py: Math.round(py) };
}

function previewDrawSegments(segments, canvas, xRangeMm, yRangeMm) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.lineWidth = 1;
    ctx.lineCap = 'round';

    for (const [x1, y1, x2, y2, cIdx] of segments) {
        const color = PREVIEW_PALETTE[cIdx % PREVIEW_PALETTE.length];
        const p1 = previewMapToPixels(x1, y1, canvas.width, canvas.height, xRangeMm, yRangeMm);
        const p2 = previewMapToPixels(x2, y2, canvas.width, canvas.height, xRangeMm, yRangeMm);
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(p1.px, p1.py);
        ctx.lineTo(p2.px, p2.py);
        ctx.stroke();
    }
}

function renderPreviewFor(sourceText, canvas) {
    const width = parseInt(document.getElementById('canvasWidth').value, 10) || 300;
    const height = parseInt(document.getElementById('canvasHeight').value, 10) || 280;
    const zThreshold = parseFloat(document.getElementById('zThreshold').value) || 1.0;
    const xRangeMm = parseFloat(document.getElementById('xRange').value) || PREVIEW_DEFAULT_X_RANGE;
    const yRangeMm = parseFloat(document.getElementById('yRange').value) || PREVIEW_DEFAULT_Y_RANGE;

    canvas.width = width;
    canvas.height = height;

    if (!sourceText) return;

    try {
        const segments = previewExtractSegments(sourceText, zThreshold, xRangeMm, yRangeMm);
        previewDrawSegments(segments, canvas, xRangeMm, yRangeMm);
    } catch (err) {
        console.error("Preview error:", err);
    }
}
</script>
</body>
</html>
