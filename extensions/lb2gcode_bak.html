<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>openBrushograph LightBurn G-code Optimizer</title>
    <style>
        body { font-family: sans-serif; background: #f0f2f5; padding: 20px; color: #333; }
        .container { max-width: 900px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h2 { color: #0056b3; margin-top: 0; }
        .form-row { display: flex; flex-wrap: wrap; gap: 10px; }
        .form-group { margin-bottom: 15px; flex: 1 1 150px; min-width: 150px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="number"], input[type="file"] { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
        input[type="checkbox"] { margin-right: 5px; }
        button { background: #0056b3; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px; width: 100%; }
        button:hover { background: #004494; }
        #status { margin-top: 15px; padding: 10px; background: #e9ecef; border-radius: 4px; white-space: pre-wrap; display: none; max-height: 200px; overflow-y: auto; font-size: 13px; }
        .success { color: #008000; }
        .error { color: #c00000; }
        .small { font-size: 12px; color: #555; }
    </style>
</head>
<body>

<div class="container">
    <h2>ðŸŽ¨ lb2gcode</h2>
    <p>
        Select a G-code file exported from LightBurn. The optimizer will insert color-picks and washing sequences, reformat G-code, and enforce distance-based color pick-ups.
    </p>

    <div class="form-row">
        <div class="form-group">
            <label for="distance">Distance threshold (mm):</label>
            <input type="number" id="distance" value="100" step="1" min="1">
            <div class="small">Path length before suggesting a color pickup.</div>
        </div>
        <div class="form-group">
            <label for="forceMultiplier">Force multiplier:</label>
            <input type="number" id="forceMultiplier" value="2.0" step="0.1" min="1.0">
            <div class="small">Only force pickups when path &gt;= multiplier Ã— threshold.</div>
        </div>
    </div>

    <div class="form-row">
        <div class="form-group">
            <label>
                <input type="checkbox" id="aggressive">
                Aggressive mode
            </label>
            <div class="small">Insert pickups at any G0/G1 once threshold is exceeded.</div>
        </div>
        <div class="form-group">
            <label>
                <input type="checkbox" id="analyzeOnly">
                Analyze only (no optimization)
            </label>
            <div class="small">Print structure statistics, keep original G-code.</div>
        </div>
    </div>

    <div class="form-row">
        <div class="form-group">
            <label for="color1Layers">Layer names for Color 1 (comma-separated):</label>
            <input type="text" id="color1Layers" value="Green, C00, C1">
            <div class="small">Example: Green, C00, C1</div>
        </div>
        <div class="form-group">
            <label for="color2Layers">Layer names for Color 2 (comma-separated):</label>
            <input type="text" id="color2Layers" value="Blue, C2">
            <div class="small">Example: Blue, C2</div>
        </div>
    </div>

    <div class="form-row">
        <div class="form-group">
            <label for="color3Layers">Layer names for Color 3 (comma-separated):</label>
            <input type="text" id="color3Layers" value="Red, C03, C3">
            <div class="small">Example: Red, C03, C3</div>
        </div>
        <div class="form-group">
            <label for="washLayers">Layer names for Washing / no color (comma-separated):</label>
            <input type="text" id="washLayers" value="Wash">
            <div class="small">These layers trigger a washing sequence instead of color pickup.</div>
        </div>
    </div>

    <div class="form-group">
        <label for="fileInput">Select G-code:</label>
        <input type="file" id="fileInput" accept=".gcode,.nc,.txt">
    </div>

    <button onclick="runOptimizer()">Optimize and Download</button>

    <div id="status"></div>
</div>

<script>
// --- Sequences copied/translated from Python optimizer ---
const HOMING_SEQUENCE = `
G0 Z10 F500;      ; Move to clearance level - Z motion limited to 500
; G0 X-10 Y-10 F1200; Homing
; G0 X-5 Y-5 F1200; go in
; G10 P0 L20 X0 Y0; set to zero
G1 F1200;           ; Set feed rate to 1000
`;

const COLOR1_SEQUENCE = `
; Color picking sequence
G1 Z10 F1000;         ; Raise brush to safe height
G0 X41 Y5 F1200;    ; Rapid move to color 1 position
G1 Z0 F1000;         ; Lower into color - controlled movement
G1 X40.102Y7.295Z0S800F1200
G1 X40.026Y7.642Z0F1200
G1 X40Y8Z0F1200
G1 X40.026Y8.358Z0F1200
G1 X40.102Y8.705Z0F1200
G1 X40.225Y9.041Z0F1200
G1 X40.393Y9.362Z0F1200
G1 X40.603Y9.668Z0F1200
G1 X40.854Y9.957Z0F1200
G1 X41.142Y10.226Z0F1200
G1 X41.464Y10.475Z0F1200
G1 X41.82Y10.701Z0F1200
G1 X42.204Y10.902Z0F1200
G1 X42.617Y11.078Z0F1200
G1 X43.054Y11.225Z0F1200
G1 X43.513Y11.343Z0F1200
G1 X43.992Y11.429Z0F1200
G1 X44.489Y11.482Z0F1200
G1 X45Y11.5Z0F1200
G1 X45.511Y11.482Z0F1200
G1 X46.008Y11.429Z0F1200
G1 X46.487Y11.343Z0F1200
G1 X46.946Y11.225Z0F1200
G1 X47.383Y11.078Z0F1200
G1 X47.796Y10.902Z0F1200
G1 X48.18Y10.701Z0F1200
G1 X48.536Y10.475Z0F1200
G1 X48.858Y10.226Z0F1200
G1 X49.146Y9.957Z0F1200
G1 X49.397Y9.668Z0F1200
G1 X49.607Y9.362Z0F1200
G1 X49.775Y9.041Z0F1200
G1 X49.898Y8.705Z0F1200
G1 X49.974Y8.358Z0F1200
G1 X50Y8Z0F1200
G1 X49.974Y7.642Z0F1200
G1 X49.898Y7.295Z0F1200
G1 X49.775Y6.959Z0F1200
G1 X49.607Y6.638Z0F1200
G1 X49.397Y6.332Z0F1200
G1 X49.146Y6.043Z0F1200
G1 X48.858Y5.774Z0F1200
G1 X48.536Y5.525Z0F1200
G1 X48.18Y5.299Z0F1200
G1 X47.796Y5.098Z0F1200
G1 X47.383Y4.922Z0F1200
G1 X46.946Y4.775Z0F1200
G1 X46.487Y4.657Z0F1200
G1 X46.008Y4.571Z0F1200
G1 X45.511Y4.518Z0F1200
G1 X45Y4.5Z0F1200
G1 X44.489Y4.518Z0F1200
G1 X43.992Y4.571Z0F1200
G1 X43.513Y4.657Z0F1200
G1 X43.054Y4.775Z0F1200
G1 X42.617Y4.922Z0F1200
G1 X42.204Y5.098Z0F1200
G1 X41.82Y5.299Z0F1200
G1 X41.464Y5.525Z0F1200
G1 X41.142Y5.774Z0F1200
G1 X40.854Y6.043Z0F1200
G1 X40.603Y6.332Z0F1200
G1 X40.393Y6.638Z0F1200
G1 X40.225Y6.959Z0F1200
G1 Z7 F800;         ; Raise from color - controlled movement
G1 X34 Y8 Z1 F1200;     ; Movement in paint - controlled movement
G1 X24 Y18 Z8 F500;     ; Move in paint - controlled movement
G1 F1200;           ; Set feed rate to 1000
`;

function offsetXInGcodeBlock(block, dx) {
    const pattern = /X(\s*)(-?\d+(?:\.\d+)?)/g;
    return block.replace(pattern, (match, space, orig) => {
        let decimals = 0;
        if (orig.includes('.')) {
            decimals = orig.split('.')[1].length;
        }
        let newVal = parseFloat(orig) + dx;
        if (Number.isNaN(newVal)) return match;
        if (decimals > 0) {
            return `X${space}${newVal.toFixed(decimals)}`;
        } else {
            return `X${space}${Math.round(newVal)}`;
        }
    });
}

const COLOR2_SEQUENCE = offsetXInGcodeBlock(COLOR1_SEQUENCE, 45);
const COLOR3_SEQUENCE = offsetXInGcodeBlock(COLOR1_SEQUENCE, 90);

const WASHING_SEQUENCE = `
; Washing sequence (no color)
G1 Z10 F1000;        ; Raise brush to safe height
G0 X5 Y5 F1200;     ; Rapid move to brush cleaning position
G1 Z-1 F800;         ; Lower brush for cleaning - controlled movement
G1 X10 Y12 Z8 F1200;     ; Rapid move to brush cleaning position
G1 Z-1 F800;         ; Lower brush for cleaning - controlled movement
G1 X25 Y14 Z6 F800;     ; Move across cleaning area - controlled movement
G1 Z8 F800;         ; Maintain brush height - controlled movement
G0 X5 Y5 F1200;     ; Rapid move to brush cleaning position
G1 Z-1 F800;         ; Lower brush for cleaning - controlled movement
G1 X15 Y12 Z8 F1200;     ; Rapid move to brush cleaning position
G1 Z-1 F800;         ; Lower brush for cleaning - controlled movement
G1 X25 Y14 Z6 F800;     ; Move across cleaning area - controlled movement
G1 Z10 F800;         ; Maintain brush height - controlled movement
G1 F1200;           ; Set feed rate to 1000
`;

const ENDING_SEQUENCE = `
; Return to 2,0 wash and park
G1 Z10 F1000;        ; Raise brush to safe height
G0 X5 Y5 F1200;     ; Rapid move to brush cleaning position
G1 Z-1 F800;         ; Lower brush for cleaning - controlled movement
G1 X10 Y12 Z8 F1200;     ; Rapid move to brush cleaning position
G1 Z-1 F800;         ; Lower brush for cleaning - controlled movement
G1 X25 Y14 Z6 F800;     ; Move across cleaning area - controlled movement
G0 X5 Y5 F1200;     ; Rapid move to brush cleaning position
G1 Z-1 F800;         ; Lower brush for cleaning - controlled movement
G1 X15 Y12 Z8 F1200;     ; Rapid move to brush cleaning position
G1 Z-1 F800;         ; Lower brush for cleaning - controlled movement
G1 X25 Y14 Z6 F800;     ; Move across cleaning area - controlled movement
G1 Z10 F800;         ; Maintain brush height - controlled movement
G0 X20 Y130 Z10 F500;; Move to parking position with Z at safe height
M2;                 ; End program
`;

// Default mapping from layer names to color sequences
const DEFAULT_LAYER_COLOR_MAP = {
    "Green": { sequence: COLOR1_SEQUENCE, name: "Color 1" },
    "Blue":  { sequence: COLOR2_SEQUENCE, name: "Color 2" },
    "Red":   { sequence: COLOR3_SEQUENCE, name: "Color 3" },
    "C03":   { sequence: COLOR3_SEQUENCE, name: "Color 3" },
    "C00":   { sequence: COLOR1_SEQUENCE, name: "Color 1" },
    "C1":    { sequence: COLOR1_SEQUENCE, name: "Color 1" },
    "C2":    { sequence: COLOR2_SEQUENCE, name: "Color 2" },
    "C3":    { sequence: COLOR3_SEQUENCE, name: "Color 3" },
    "Wash":  { sequence: WASHING_SEQUENCE, name: "Washing" },
    "default": { sequence: WASHING_SEQUENCE, name: "Washing" }
};

function parseLayerList(text) {
    if (!text) return [];
    return text
        .split(',')
        .map(s => s.trim())
        .filter(s => s.length > 0);
}

function buildLayerColorMapFromUI() {
    // Start from defaults so we always have sane behavior
    const map = { ...DEFAULT_LAYER_COLOR_MAP };

    const color1Layers = parseLayerList(document.getElementById('color1Layers')?.value || "");
    const color2Layers = parseLayerList(document.getElementById('color2Layers')?.value || "");
    const color3Layers = parseLayerList(document.getElementById('color3Layers')?.value || "");
    const washLayers   = parseLayerList(document.getElementById('washLayers')?.value   || "");

    // Helper to register all names for a given color
    function assignLayers(layerNames, sequence, name) {
        for (const ln of layerNames) {
            map[ln] = { sequence, name };
        }
    }

    if (color1Layers.length) assignLayers(color1Layers, COLOR1_SEQUENCE, "Color 1");
    if (color2Layers.length) assignLayers(color2Layers, COLOR2_SEQUENCE, "Color 2");
    if (color3Layers.length) assignLayers(color3Layers, COLOR3_SEQUENCE, "Color 3");
    if (washLayers.length)   assignLayers(washLayers,   WASHING_SEQUENCE, "Washing");

    return map;
}

function nextZLiftInRange(lines, startIndex, maxLookahead) {
    const re = /G0\s*Z[1-9]|G0.*Z[1-9]/;
    const endIndex = Math.min(startIndex + maxLookahead, lines.length);
    for (let i = startIndex; i < endIndex; i++) {
        if (re.test(lines[i])) return i - startIndex;
    }
    return null;
}

function analyzeGcode(lines) {
    let drawing_areas = 0;
    let z_moves = 0;
    let z0_moves = 0;
    let g0_moves = 0;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (/G0\s*Z[0-9.]+/.test(line)) {
            z_moves++;
            if (i + 2 < lines.length) {
                if (/G0\s*X[0-9.]+Y[0-9.]+/.test(lines[i+1]) && /G1\s*Z0/.test(lines[i+2])) {
                    drawing_areas++;
                }
            }
        }
        if (/G1\s*Z0/.test(line)) z0_moves++;
        if (/G0\s*X|G0\s*Y/.test(line)) g0_moves++;
    }

    return {
        totalLines: lines.length,
        drawingAreas: drawing_areas,
        zMoves: z_moves,
        z0Moves: z0_moves,
        g0Moves: g0_moves,
    };
}

function optimizeGcodeText(text, options) {
    const { distanceThreshold, forceMultiplier, debug, aggressive, layerColorMap } = options;

    const rawLines = text.split(/\r?\n/);
    const lines = rawLines.map(l => l.endsWith("\n") ? l : l + "\n");

    // Analysis-only path
    if (options.analyzeOnly) {
        const stats = analyzeGcode(lines);
        let report = [];
        report.push(`G-code Analysis:`);
        report.push(`  Total lines: ${stats.totalLines}`);
        report.push(`  Detected drawing areas: ${stats.drawingAreas}`);
        report.push(`  Z movements (lifts): ${stats.zMoves}`);
        report.push(`  Z0 movements (drawing): ${stats.z0Moves}`);
        report.push(`  G0 positioning moves: ${stats.g0Moves}`);
        return { optimizedText: text, report: report.join("\n") };
    }

    // Use provided map or fall back to defaults
    const LAYER_COLOR_MAP = layerColorMap || DEFAULT_LAYER_COLOR_MAP;

    let total_length = 0;
    let accumulated_length = 0;
    let current_x = 0, current_y = 0;
    let prev_x = 0, prev_y = 0;
    let is_drawing = false;
    let current_segment_length = 0;
    let layer_lengths = {};
    let path_lengths = {};
    let current_path = "None";
    let current_layer = "default";
    let previous_layer = null;
    let pickup_segments = [];
    let color_pickup_count = { "Color 1": 0, "Color 2": 0, "Color 3": 0, "Washing": 0 };

    let current_color_sequence = WASHING_SEQUENCE;
    let current_color_name = "Washing";
    let last_color_name = null;

    const coord_regex = /G[01]\s*X([\d.-]+)Y([\d.-]+)Z[\d.-]+F/;
    const layer_regex = /;Layer\s+(\w+)/;
    const m8_regex = /M8/;
    const path_regex = /; Path\s+(\d+)/;
    const plunge_regex = /Z0F/;
    const retract_regex = /Z[2-9]F/;
    const cut_header_regex = /;\s*Cut\s*@\s*(\d+)\s*mm\/min/i;

    let output_lines = [];
    output_lines.push(HOMING_SEQUENCE);

    let line_index = 0;
    let processed_count = 0;
    let found_m8 = false;
    let current_cut_feedrate = null;
    let pending_original_lines = [];

    function flush_pending(buffer_feedrate) {
        if (!pending_original_lines.length) return;
        if (buffer_feedrate != null) {
            const rep = String(buffer_feedrate);
            const re = /(?<=F)1800\b/;
            for (const pl of pending_original_lines) {
                output_lines.push(pl.replace(re, rep));
            }
        } else {
            output_lines.push(...pending_original_lines);
        }
        pending_original_lines = [];
    }

    while (line_index < lines.length) {
        let line = lines[line_index];

        const cut_match = line.match(cut_header_regex);
        if (cut_match) {
            flush_pending(current_cut_feedrate);
            let parsed = parseInt(cut_match[1], 10);
            if (!Number.isFinite(parsed)) parsed = null;
            current_cut_feedrate = parsed;
        }

        if (m8_regex.test(line)) {
            flush_pending(current_cut_feedrate);
            found_m8 = true;
            output_lines.push(line);
            line_index++;

            const look_ahead_limit = 6;
            let next_layer = null;
            let look_ahead_index = line_index;

            for (let i = 0; i < look_ahead_limit; i++) {
                if (look_ahead_index < lines.length) {
                    const ahead_line = lines[look_ahead_index];
                    const lm = ahead_line.match(layer_regex);
                    if (lm) {
                        next_layer = lm[1];
                        break;
                    }
                    look_ahead_index++;
                }
            }

            if (next_layer && LAYER_COLOR_MAP[next_layer]) {
                current_layer = next_layer;
                if (current_layer !== previous_layer) {
                    if (!layer_lengths[current_layer]) layer_lengths[current_layer] = 0;
                    accumulated_length = 0;
                    current_segment_length = 0;

                    const previous_color_name = current_color_name || "None";
                    current_color_sequence = LAYER_COLOR_MAP[current_layer].sequence;
                    current_color_name = LAYER_COLOR_MAP[current_layer].name;

                    if (previous_color_name !== "None" && previous_color_name !== current_color_name) {
                        output_lines.push(WASHING_SEQUENCE);
                        color_pickup_count["Washing"]++;
                    }

                    output_lines.push(current_color_sequence);
                    color_pickup_count[current_color_name]++;
                    previous_layer = current_layer;
                    last_color_name = current_color_name;
                }
            }
            continue;
        }

        let layer_match = line.match(layer_regex);
        if (layer_match && !found_m8) {
            flush_pending(current_cut_feedrate);
            current_layer = layer_match[1];
            if (current_layer !== previous_layer && previous_layer == null) {
                if (!layer_lengths[current_layer]) layer_lengths[current_layer] = 0;
                accumulated_length = 0;

                if (LAYER_COLOR_MAP[current_layer]) {
                    current_color_sequence = LAYER_COLOR_MAP[current_layer].sequence;
                    current_color_name = LAYER_COLOR_MAP[current_layer].name;
                } else {
                    current_color_sequence = LAYER_COLOR_MAP["default"].sequence;
                    current_color_name = LAYER_COLOR_MAP["default"].name;
                }

                const previous_color_name = last_color_name || "None";
                if (previous_color_name !== "None" && previous_color_name !== current_color_name) {
                    output_lines.push(WASHING_SEQUENCE);
                    color_pickup_count["Washing"]++;
                }

                output_lines.push(current_color_sequence);
                color_pickup_count[current_color_name]++;
                previous_layer = current_layer;
                last_color_name = current_color_name;
            }
        }

        if (layer_match) {
            found_m8 = false;
            if (current_layer !== previous_layer) {
                accumulated_length = 0;
                current_segment_length = 0;
            }
        }

        if (/G1 Z3\.0000/.test(line)) {
            output_lines.push("G1 Z3 F1000;         ; Raise brush\n");
        } else if (/G1 Z0\.0000/.test(line)) {
            output_lines.push("G1 Z0 F1000;         ; Position at surface\n");
        } else if (/G1 Z-0\.1000 F500/.test(line)) {
            output_lines.push("G1 Z-0.1 F1000;      ; Plunge brush to painting depth\n");
        } else {
            pending_original_lines.push(line);
        }

        const path_match = line.match(path_regex);
        if (path_match) {
            current_path = path_match[1];
            path_lengths[current_path] = 0;
        }

        if (retract_regex.test(line)) is_drawing = false;
        if (plunge_regex.test(line)) is_drawing = true;

        const coord_match = line.match(coord_regex);
        if (coord_match) {
            prev_x = current_x;
            prev_y = current_y;
            current_x = parseFloat(coord_match[1]);
            current_y = parseFloat(coord_match[2]);

            if ((prev_x !== 0 || prev_y !== 0) && is_drawing && line.includes("G1")) {
                const dx = current_x - prev_x;
                const dy = current_y - prev_y;
                const segment_length = Math.sqrt(dx*dx + dy*dy);
                total_length += segment_length;
                accumulated_length += segment_length;

                layer_lengths[current_layer] = (layer_lengths[current_layer] || 0) + segment_length;
                path_lengths[current_path] = (path_lengths[current_path] || 0) + segment_length;
                current_segment_length += segment_length;

                if (accumulated_length > distanceThreshold) {
                    let is_clean_transition = false;
                    let force_pickup = false;

                    if (aggressive) {
                        if (/G[01]/.test(line)) {
                            is_clean_transition = true;
                        }
                    } else {
                        if (/G0\s*Z[1-9]|G0.*Z[1-9]/.test(line)) {
                            is_clean_transition = true;
                        } else if (line_index > 0 && line_index + 1 < lines.length) {
                            const prev_is_g1 = /G1\s*X|G1\s*Y/.test(lines[line_index - 1]);
                            const next_is_g0 = /G0\s*/.test(lines[line_index + 1]);
                            if (prev_is_g1 && next_is_g0) {
                                is_clean_transition = true;
                            }
                        }
                    }

                    if (!aggressive && !is_clean_transition) {
                        force_pickup = accumulated_length >= (forceMultiplier * distanceThreshold);
                        if (force_pickup) {
                            const z_lift_distance = nextZLiftInRange(lines, line_index, 20);
                            if (z_lift_distance != null && z_lift_distance < 10) {
                                force_pickup = false;
                            } else if (/G[01]/.test(line)) {
                                is_clean_transition = true;
                            }
                        }
                    } else if (aggressive && !is_clean_transition) {
                        force_pickup = accumulated_length >= (forceMultiplier * distanceThreshold);
                        if (force_pickup && /G[01]/.test(line)) {
                            is_clean_transition = true;
                        }
                    }

                    if (accumulated_length >= (3.0 * distanceThreshold) && !is_clean_transition) {
                        is_clean_transition = true;
                    }

                    if (is_clean_transition) {
                        flush_pending(current_cut_feedrate);
                        if (LAYER_COLOR_MAP[current_layer]) {
                            current_color_name = LAYER_COLOR_MAP[current_layer].name;
                            current_color_sequence = LAYER_COLOR_MAP[current_layer].sequence;
                        } else {
                            current_color_name = LAYER_COLOR_MAP["default"].name;
                            current_color_sequence = LAYER_COLOR_MAP["default"].sequence;
                        }

                        if (last_color_name && last_color_name !== current_color_name) {
                            output_lines.push(WASHING_SEQUENCE);
                            color_pickup_count["Washing"]++;
                        }

                        color_pickup_count[current_color_name]++;
                        output_lines.push(current_color_sequence);
                        last_color_name = current_color_name;

                        pickup_segments.push([current_layer, current_color_name, accumulated_length]);

                        accumulated_length = 0;
                        current_segment_length = 0;
                    }
                }
            }
        }

        line_index++;
        processed_count++;
    }

    flush_pending(current_cut_feedrate);
    output_lines.push(ENDING_SEQUENCE);

    let optimized_g_code = "";
    for (const l of output_lines) {
        if (!l.endsWith("\n")) optimized_g_code += l + "\n";
        else optimized_g_code += l;
    }

    let report = [];
    report.push(`Total drawing path length: ${total_length.toFixed(2)} mm (${(total_length/1000).toFixed(2)} m)`);
    report.push("");
    report.push("Layer Lengths:");
    for (const [layer, length] of Object.entries(layer_lengths)) {
        report.push(`  Layer ${layer}: ${length.toFixed(2)} mm`);
    }
    report.push("");
    report.push("Path Segments Between Color Pickups:");
    for (const seg of pickup_segments) {
        report.push(`  Layer ${seg[0]}, Color ${seg[1]}: ${seg[2].toFixed(2)} mm`);
    }
    report.push("");
    report.push("Color Pickup Insertions:");
    for (const [color, count] of Object.entries(color_pickup_count)) {
        if (count > 0) report.push(`  ${color}: ${count} pickups added`);
    }

    return { optimizedText: optimized_g_code, report: report.join("\n") };
}

function runOptimizer() {
    const fileInput = document.getElementById('fileInput');
    const statusDiv = document.getElementById('status');
    const distance = parseFloat(document.getElementById('distance').value);
    const forceMultiplier = parseFloat(document.getElementById('forceMultiplier').value);
    const aggressive = document.getElementById('aggressive').checked;
    const analyzeOnly = document.getElementById('analyzeOnly').checked;

    if (!fileInput.files.length) {
        alert("Please select a G-code file.");
        return;
    }

    const file = fileInput.files[0];
    const reader = new FileReader();

    statusDiv.style.display = 'block';
    statusDiv.textContent = "Reading file...";

    reader.onload = function(e) {
        try {
            const content = e.target.result;
            const layerColorMap = buildLayerColorMapFromUI();
            const { optimizedText, report } = optimizeGcodeText(content, {
                distanceThreshold: distance,
                forceMultiplier: forceMultiplier,
                aggressive: aggressive,
                analyzeOnly: analyzeOnly,
                debug: false,
                layerColorMap: layerColorMap
            });

            statusDiv.textContent = report;

            const blob = new Blob([optimizedText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = (analyzeOnly ? "analyzed_" : "optimized_") + file.name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            statusDiv.innerHTML = `<span class="success">Done. Downloading '${a.download}'.</span>\n\n` + report;
        } catch (err) {
            console.error(err);
            statusDiv.innerHTML = `<span class="error">Error: ${err.message}</span>`;
        }
    };

    reader.onerror = function() {
        statusDiv.innerHTML = `<span class="error">Error reading file.</span>`;
    };

    reader.readAsText(file);
}
</script>

</body>
</html>
